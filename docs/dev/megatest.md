# Каждая горутина пишет в лог:
- при начале действия:
  - имя rv
    - название действия и параметры
  - при окончании действия
    - имя rv
    - название действия и параметры
    - результат
    - сколько заняло времени
  - если она следит, то при смене состояния
    - имя rv
    - ожидаемое состояние
    - наблюдаемое состояние

# Пачка горутин
## volume-checker(rv)
Собирает статистику по переходам состояния rv ориентируясь на condition.
  - следит (Watch вместо Get каждые N секунд), что с rv все ок.
    - condition остается RV.ioReady==True
    - condition остается RV.Quorum==True
  - при переключении состояния - писать в лог с Reason и Message если Condition status меняется. Записать в структуру rvName, кол-во переходов для каждого из condition, в начале condition должны быть в true. Написать  в лог condition rvr == false.
    Таким образом четное кол-во переходов указывает на то, что rv поддерживает нужное состояние несмотря на попытки ее развалить, а нечетное, что попытки удались. В идеале нужно иметь счетчики переходов по нулям.
  - когда получает сигнал окончания — выходит
## volume-attacher (rv, period_min, period_max)
Эмулирует работу CSI, публикуя RV на разных нодах через ресурсы **RVA** (`ReplicatedVolumeAttachment`).
  - в цикле:
    - ждет рандом
    - случайным образом выбирает одну ноду(wantedNodeName) с label sds-replicated-volume.
    - в зависимости от количества активных **RVA** (т.е. желаемых прикреплений):
      - 0: 
        - rand(100) > 10 - обычный цикл (добавим одну и уберем одну) (0 нод на выходе)
        - rand(100) < 10 - Attach цикл (только добавить 1 ноду) (1 нод на выходе)
      - 1 : 
        - wantedNodeName не находится среди RVA - тогда цикл эмуляции миграции (создаём новую RVA, удаляем старую RVA, затем удаляем новую) (0 нод на выходе)
        - wantedNodeName уже находится среди RVA - тогда только detach цикл (удалить RVA) (0 нод на выходе)
      - 2: - кейс когда контроллер упал и поднялся
        - wantedNodeName находится или не находится среди RVA - делаем Detach цикл, удаляем случайную RVA (1 на выходе).
                 
      Таким образом у нас большая часть будет с 0 нод(вне цикла работы volume-attacher), а часть с 1 нодой для эмуляции миграции.
      Итого:
      из 0 нод с шаном 5% мы делаем 1 ноду(без этого у нас всегда будет оставаться 0 и мы спустя какое-то время после старта никогда не получим 2), а обычно не делаем(оставлем 0 на выходе)
      из 1 ноды мы делаем 0, но с разным подходом: либо сразу либо с эмуляцией миграции(временно делаем 2, затем 0)
      из 2 нод мы делаем 1.
      

    - **Обычный цикл** (добавим одну и уберем одну):
      - делает действие паблиш: **создаёт RVA** для выбранной ноды (не затрагивая другие RVA).
        - дожидается успеха: `rva.status.conditions[type=Ready].status=True` (reason=`Attached`) и/или `rv.status.actuallyAttachedTo` содержит выбранную ноду.
      - ждет рандом
      - делает действие анпаблиш **выбранной ноды**: удаляет соответствующую RVA (если она существует)
        - дожидается успеха: `rv.status.actuallyAttachedTo` не содержит выбранную ноду (и/или RVA удалена).
        - пишет в лог о любых действиях или бездействиях (когда ноды 2)
    - **Detach цикл** (убрать одну ноду):
      - действие анпаблиш **выбранной ноды**: удаляет RVA (если она существует)
        - дожидается успеха: `rv.status.actuallyAttachedTo` не содержит выбранную ноду
        - пишет в лог о любых действиях или бездействиях (когда ноды 2)
    - **Attach цикл** (только добавить 1 ноду):
      - делает действие паблиш: создаёт RVA для выбранной ноды
        - дожидается успеха: RVA Ready=True и/или `rv.status.actuallyAttachedTo` содержит выбранную ноду
        - пишет в лог
    - **Цикл эмуляции миграции** (создаём новую RVA, удаляем старую RVA, затем удаляем новую)
      - делает действие паблиш: создаёт RVA для выбранной новой ноды
        - дожидается успеха: `rv.status.actuallyAttachedTo` содержит выбранную новую ноду (и при необходимости обе, если в итоге должно быть 2)
      - действие анпаблиш **старой ноды**: удаляет RVA старой ноды
        - дожидается успеха: `rv.status.actuallyAttachedTo` не содержит старую ноду
        - пишет в лог о любых действиях или бездействиях (когда ноды 2)
      - ждет рандом
      - действие анпаблиш **выбранной новой ноды**: удаляет RVA выбранной новой ноды
        - дожидается успеха: `rv.status.actuallyAttachedTo` не содержит выбранную новую ноду
        - пишет в лог о любых действиях или бездействиях (когда ноды 2)

  - когда получает сигнал окончания
    - делает действие анпаблиш
      - удаляет все RVA для данного RV
      - дожидается успеха 
    - выходит
## volume-resizer(rv, period_min, period_max, step_min, step_max) - ОТЛОЖЕНО!
Меняет размеры rv.
TODO: не увеличивать размер > maxRvSize
  - в цикле 
    - ждет рандом
    - делает действие ресайза
      - увеличивает размер в rv на случайный размер в диапазоне
      - дожидается успеха
  - когда получает сигнал окончания
    - выходит
## volume-replica-destroyer (rv, period_min, period_max)
Удаляет случайные rvr у rv.
  - в цикле пока не выйдем, с случайным интервалом из (period_min+max)
    - ждет рандом(в интервале выше)
    - случайным образом выбирает rvr из тех которые у нас в данном rv.
    - выполняет действие удаления:
      - вызывает delete на rvr
      - НЕ дожидается успеха
      - пишет в лог , который уже структурирован, действие
  - когда получает сигнал окончания
    - выходит
## volume-replica-creator (rv, period_min, period_max)
Создает случайные rvr у rv.
  - в цикле пока не выйдем, с случайным интервалом из (period_min+max)
    - ждет рандом (в интервале выше)
    - случайным образом выбирает тип rvr:
      - Access или TieBreaker
      - Diskful пока не создаем (у нас нет удалятора лишних diskful пока)
    - выполняет действие создания rvr c выбранным типом.
      - создает rvr
      - НЕ дожидается успеха
      - пишет в лог, который уже структурирован, тип и действие
  - когда получает сигнал окончания
    - выходит
## volume-main (rv, sc, lifetime_period)
  - рандомом выбирает, сколько нод сразу в паблиш (это первоначальное состояние кластера при запуске megatest, далее поддерживать такое не надо)
    - 0 — 30%
    - 1 — 60%
    - 2 — 10%
  - рандомом выбирает, то количество нод, которое получили на предыдущем шаге
  - выполняет действие создать rv
    - создает rv
    - запускает:
      - volume-attacher(rv, 30, 60) - подумать над интервалами
      - volume-attacher(rv, 100, 200) - РЕШИЛИ НЕ ДЕЛАТЬ!
      - volume-resizer(rv, 50, 50, 4kb, 64kb) - ОТЛОЖЕНО! - контроллер ресайза может увеличить rv больше чем запрошено, если это требуется на более низком уровне, поэтому проверка должна это учитывать. Но нужно уточнить порог срабатывания  sds-node-configurator - он может не увеличивать на малые значения. 
      - volume-replica-destroyer (rv, 30, 300)
      - volume-replica-creator (rv, 30, 300)
    - дожидается, что станет ready
  - запускает
    - volume-checker(rv)
  - когда ей посылают сигнал окончания или истекает lifetime_period
    - останавливает:
      - volume-checker
      - volume-attacher’ы
    - выполняет действие удаление rv
      - дожидается успеха
    - останавливает
      - volume-resizer
      - volume-replica-destroyer
      - volume-replica-creator
    - выходит
## pod-destroyer (ns, label_selector, pod_min, pod_max, period_min, period_max)
Удаляет поды control-plane по label_selector
  - в цикле:
    - ждет рандом rand(period_min, period_max)
    - выбирает поды с заданным label_selector, перемешивает список (на статус не смотрит)
    - выбирает случайное число из (rand(pod_min, pod_max))
    - делает delete выбранного числа pod'ов с начала списка
    - не дожидается удаления
  - когда ей посылают сигнал окончания
    - выходит
## multivolume(list sc, max_vol, step_min, step_max, step_period_min, step_period_max, vol_period_min, vol_period_max)
Оркестратор горутин (он же main). 
  - запускает:
    - pod-destroyer(agent, 1, 2, 30, 60)
    - pod-destroyer(controller, 1, 3, 30, 60)
    - pod-destroyer(kube-apiserver, 1, 3, 120, 240) - ПОКА НЕ ДЕЛАЕМ (т.е. kube-apiserver это статичный под)!
  - в цикле
    - если количество запущенных volume_main < max_vol
      - выбирает случайным образом количество для запуска (step_min, step_max), может превышать max_vol
      - в цикле для каждого N
        - выбирает случайный scName
        - выбирает случайный vol_period
        - генерирует случайное имя rvName
        - запускает volume-main(rvName, scName, vol_period)
    - ждет рандом(step_period_min, step_period_max)
  - когда ей посылают сигнал окончания
    - останавливает всё запущенное
    - выходит
