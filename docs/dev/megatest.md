# Каждая го-рутина пишет в лог:
- при начале действия:
  - имя rv
    - название действия и параметры
  - при окончании действия
    - имя rv
    - название действия и параметры
    - результат
    - сколько заняло времени
  - если она следит, то при смене состояния
    - имя rv
    - ожидаемое состояние
    - наблюдаемое состояние

# Пачка го-рутин
## volume-checker(rv)
  - следит(Watch вмепсте Get каждые N секунд), что с rv все ок. Пока(без данных от rvr, следим за изменениями RV.)
    - condition остается RV.ioReady==True
    - condition остается RV.Quorum==True
  - при переключении состояния - писать в лог с Reason и Message если Contion status меняется, а так же  время переключения, считать количество раз и показать в конце(записать в структуру для сбора в стату для вернего уровня). Без инфы от rvr, по крайней мере пока. В стте: имя rv, False-> True, True->False коунтеры для каждого из кондишенов, или рассмотреть возмонсть более детально с Reason.
  - когда получает сигнал окончания — выходит
## volume-publisher (rv, period_min, period_max)
  - в цикле:
    - ждет рандом
    - случайным образом выбирает одну ноду(wantedNodeName) с label sds-replicated-volume.
    - в завивимости от количества нод в PublesdON:
      - 0:
        - rand(100) > 5 - обычный цикл
        - rand(100) < 5 - Publish цикл
      - 1 : 
        - wantedNodeName не находится в PublishOn - тогда ~~обычный цикл~~ цикл эмуляции миграции
        - wantedNodeName уже находится в PublishOn - тогда только unpublish цикл
      - 2:
        - wantedNodeName находится в списке - делаем Unblish цикл
        - wantedNodeName не находится в списке - удаляем случайную.
        
      Таким образом у нас большая часть будет с 0 нод(вне цикла работы volume-publisher), а часть с 1 нодой для эмуляции миграции.
      Итого:
      из 0 нод с шаном 5% мы делаем 1 ноду(без этого у нас всегда будет оставаться 0 и мы спустя какое-то время после старта никогда не получим 2), а обычно не делаем(оставлем 0 на выходе)
      из 1 ноды мы делаем 0, но с разным подходом: либо сразу либо с эмуляцией миграции(временно делаем 2, затем 0)
      из 2 нод мы делаем 1.
      

     - **Обычный цикл**(добавим одну и уберем одну, если их там нет или одна одна):
       - делает действие паблиш: в rv.spec.PublishOn добавлет еще одну ноду не перезаписывая сущестуют(но гадя в лог если их уже 2 и мы попыталсь записать 3, ну или оно само должно сломаться).
         - дожидается успеха: rv.status.PublushedOn содержит в том числе выбранную ноду
       - ждет рандом
       - делает действие анпаблиш **выбранной ноды**(выше), если publichOn содержит эту ноду(должен содержать на этом этапе)
        - меняет publichOn оставляя не выбранную ноду, если она есть
        - дожидается успеха: rv.status.PublushedOn - выбранной ноды нет в списке.
        - пишет в лог о любых действиях или бездействиях(когда ноды 2)
      - **Unpublish цикл**(когда 1 или 2 и надо просто убрать):
        - действие анпаблиш **выбранной ноды**(выше), если publichOn содержит эту ноду(должен содержать на этом этапе)
          - меняет publichOn оставляя не выбранную ноду, если она есть
          - дожидается успеха: rv.status.PublushedOn - выбранной ноды нет в списке.
          - пишет в лог о любых действиях или бездействиях(когда ноды 2)
      - **Publish цикл**(только добавить 1 ноду):
        - делает действие паблиш: в rv.spec.PublishOn добавлет еще одну ноду не перезаписывая сущестуют(но гадя в лог если их уже 2 и мы попыталсь записать 3, ну или оно само должно сломаться).
           - дожидается успеха: rv.status.PublushedOn содержит в том числе выбранную ноду
           - пишет в лог
       - **Цикл эмуляции миграции**(добавляем новую убирем из PublishOn старую, затем удаляем новую)
         - делает действие паблиш: в rv.spec.PublishOn добавлет еще одну ноду не перезаписывая сущестуют(но гадя в лог если их уже 2 и мы попыталсь записать 3, ну или оно само должно сломаться).
           - дожидается успеха: rv.status.PublushedOn содержит в том числе выбранную ноду
         - действие анпаблиш **Невыбранной(старой\сществующей) ноды**.
          - меняет publichOn оставляя выбранную ноду.
          - дожидается успеха: rv.status.PublushedOn - выбранной ноды нет в списке.
          - пишет в лог о любых действиях или бездействиях(когда ноды 2)
         - ждет рандом
         - действие анпаблиш **выбранной новой ноды**(выше), если publichOn содержит эту ноду(должен содержать на этом этапе)
          - меняет publichOn оставляя не выбранную ноду, если она есть
          - дожидается успеха: rv.status.PublushedOn - выбранной ноды нет в списке.
          - пишет в лог о любых действиях или бездействиях(когда ноды 2)

---
    TBD
    - делает действие паблиш: в rv.spec.PublishOn пихает выбранную ноду: 
    если нод нет или 1 нода - добавить новую, если 2, то  проверить что нет текущей, а зетем: либо убрать случаную, либо проигнорить(можно на осонове рандома). Возможно действия publish\unpublish дожны быть поменяны местаи, а може и нет. 
      - меняет publichOn
      - дожидается успеха: rv.status.PublushedOn содержит в том числе выбранную ноду
    - ждет рандом
    - делает действие анпаблиш **выбранной ноды**(выше), если publichOn содержит эту ноду. 
      - меняет publichOn оставляя не выбранную ноду, если она есть
      - дожидается успеха: rv.status.PublushedOn - выбранной ноды нет в списке.
      - пишет в лог о любых действиях или бездействиях(когда ноды 2)
  - когда получает сигнал окончания
    - делает действие анпаблиш
      - меняет publichOn
      - дожидается успеха 
    - выходит
## volume-resizer(rv, period_min, period_max, step_min, step_max)
  - в цикле 
    - ждет рандом
    - делает действие ресайза
      - увеличивает сайз в rv на случайный размер в диапазоне
      - дожидается успеха
  - когда получает сигнал окончания
    - выходит
## volume-replica-destroyer (rv, period_min, period_max)
  - в цикле пока не выйдем, с случайным интервалом из (period_min+max)
    - ждет рандом(в интервале выше)
    - случайным образом выбирает rvr из тех которые у нас в данном rv.
    - выполняет действие удаления:
      - вызывает delete на rvr
      - НЕ дожидается успеха
      - пишет в лог , который уже структурирован, действие
  - когда получает сигнал окончания
    - выходит
## volume-replica-creator (rv, period_min, period_max)
  - в цикле пока не выйдем, с случайным интервалом из (period_min+max)
    - ждет рандом (в интервале выше)
    - случайным образом выбирает тип rvr:
      - Access или TieBreaker
      - Diskful пока не создаем (у нас нет удалятора лишних diskful пока)
    - выполняет действие создания rvr c выбранным типом.
      - создает rvr
      - НЕ дожидается успеха
      - пишет в лог, который уже структурирован, тип и действие
  - когда получает сигнал окончания
    - выходит
## volume-main (rv, sc, lifetime_period)
  - рандомом выбирает, сколько нод сразу в паблиш(это первоначальное состояние кластера при запуске megatest, далее поддерживать такое не надо)
    - 0 — 30%
    - 1 — 60%
    - 2 — 10%
  - ~~рандомом выбирает ноды, если необходимо~~(выбираем ноды внутри)
  - выполняет действие создать rv
    - создает rv
    - запускает:
      - volume-publisher(rv, 30, 60)
      - volume-publisher(rv, 100, 200)
      - volume-resizer(rv, 50, 50, 4kb, 64kb) - контролер рейсаза может увеличить rv больше чем запроешено, если это требуется на более низком уровне, поэтому проверка должна уто учитывать. Но нужно уточнить порог срабатывания  sds-node-configurator - он может не увеличивать на малые значения. 
      - volume-replica-destroyer (rv, 30, 300)
      - volume-replica-creator (rv, 30, 300)
    - дожидается, что станет ready
  - запускает
    - volume-checker(rv)
  - когда ей посылают сигнал окончания или истекает lifetime_period
    - останавливает:
      - volume-checker
      - volume-publisher’ы
    - выполняет действие удаление rv
      - дожидается успеха
    - останавливает
      - volume-resizer
      - volume-replica-destroyer
      - volume-replica-creator
    - выходит
## pod-destroyer (ns, label_selector, pod_min, pod_max, period_min, period_max)
  - в цикле:
    - ждет рандом
    - выбирает количество pod’ов
    - выбирает необходимое количество случайных pod’ов (на статус не смотрит)
    - делает delete этих pod’ов
    - не дожидается удаления
  - когда ей посылают сигнал окончания
    - выходит
## multivolume(list sc, max_vol, step_min, step_max, step_period_min, step_period_max, vol_period_min, vol_period_max)
  - запускает:
    - pod-destroyer(agent, 1, 2, 30, 60)
    - pod-destroyer(controller, 1, 3, 30, 60)
    - pod-destroyer(kube-apiserver, 1, 3, 120, 240) - ПОКА НЕ ДЕЛАЕМ (т.е. kube-apiserver это статичный под)!
  - в цикле
    - если количество запущенных volume_main < max_vol
      - выбирает случайным образом количество для запуска (step_min, step_max), может превышать max_vol
      - в цикле для каждого N
        - выбирает случайный scName
        - выбирает случайный vol_period
        - генерирует случайное имя rvName
        - запускает volume-main(rvName, scName, vol_period)
    - ждет рандом(step_period_min, step_period_max)
  - когда ей посылают сигнал окончания
    - останавливает всё запущенное
    - выходит
