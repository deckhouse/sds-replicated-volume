# Каждая го-рутина пишет в лог:
- при начале действия:
  - имя rv
    - название действия и параметры
  - при окончании действия
    - имя rv
    - название действия и параметры
    - результат
    - сколько заняло времени
  - если она следит, то при смене состояния
    - имя rv
    - ожидаемое состояние
    - наблюдаемое состояние

# Пачка го-рутин
## volume-checker(rv)
  - следит, что с rv все ок
    - остается ready
    - остается quorum
  - когда получает сигнал окончания — выходит
## volume-publisher (rv, period_min, period_max)
  - в цикле:
    - ждет рандом
    - случайным образом выбирает ноду
    - делает действие паблиш
      - меняет publichOn
      - дожидается успеха
    - ждет рандом
    - делает действие анпаблиш
      - меняет publichOn
      - дожидается успеха
  - когда получает сигнал окончания
    - делает действие анпаблиш
      - меняет publichOn
      - дожидается успеха 
    - выходит
## volume-resizer(rv, period_min, period_max, step_min, step_max)
  - в цикле
    - ждет рандом
    - делает действие ресайза
      - увеличивает сайз в rv на случайный размер в диапазоне
      - дожидается успеха
  - когда получает сигнал окончания
    - выходит
## volume-replica-destroyer (rv, period_min, period_max)
  - в цикле
    - ждет рандом
    - случайным образом выбирает реплику
    - выполняет действие удаления
      - вызывает delete на rvr
      - НЕ дожидается успеха
  - когда получает сигнал окончания
    - выходит
## volume-replica-creator (rv, period_min, period_max)
  - в цикле
    - ждет рандом
    - случайным образом выбирает тип
      - Access или TieBreaker
      - Diskful пока не создаем (у нас нет удалятора лишних diskful пока)
    - выполняет действие создания
      - создает rvr
      - НЕ дожидается успеха
  - когда получает сигнал окончания
    - выходит
## volume-main (rv, sc, lifetime_period)
  - рандомом выбирает, сколько нод сразу в паблиш
    - 0 — 30%
    - 1 — 60%
    - 2 — 10%
  - рандомом выбирает ноды, если необходимо
  - выполняет действие создать rv
    - создает rv
    - запускает:
      - volume-publisher(rv, 30, 60)
      - volume-publisher(rv, 100, 200)
      - volume-resizer(rv, 50, 50, 4kb, 64kb)
      - volume-replica-destroyer (rv, 30, 300)
      - volume-replica-creator (rv, 30, 300)
    - дожидается, что станет ready
  - запускает
    - volume-checker(rv)
  - когда ей посылают сигнал окончания или истекает lifetime_period
    - останавливает:
      - volume-checker
      - volume-publisher’ы
    - выполняет действие удаление rv
      - дожидается успеха
    - останавливает
      - volume-resizer
      - volume-replica-destroyer
      - volume-replica-creator
    - выходит
## pod-destroyer (ns, label_selector, pod_min, pod_max, period_min, period_max)
  - в цикле:
    - ждет рандом
    - выбирает количество pod’ов
    - выбирает необходимое количество случайных pod’ов (на статус не смотрит)
    - делает delete этих pod’ов
    - не дожидается удаления
  - когда ей посылают сигнал окончания
    - выходит
## multivolume(list sc, max_vol, step_min, step_max, step_period_min, step_period_max, vol_period_min, vol_period_max)
  - запускает:
    - pod-destroyer(agent, 1, 2, 30, 60)
    - pod-destroyer(controller, 1, 3, 30, 60)
    - pod-destroyer(kube-apiserver, 1, 3, 120, 240) - ПОКА НЕ ДЕЛАЕМ (т.е. kube-apiserver это статичный под)!
  - в цикле
    - если количество запущенных volume_main < max_vol
      - выбирает случайным образом количество для запуска (step_min, step_max), может превышать max_vol
      - в цикле для каждого N
        - выбирает случайный scName
        - выбирает случайный vol_period
        - генерирует случайное имя rvName
        - запускает volume-main(rvName, scName, vol_period)
    - ждет рандом(step_period_min, step_period_max)
  - когда ей посылают сигнал окончания
    - останавливает всё запущенное
    - выходит
