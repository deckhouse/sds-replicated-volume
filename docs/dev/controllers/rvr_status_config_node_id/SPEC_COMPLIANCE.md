# Соответствие спецификации для `rvr-status-config-node-id-controller`

## Спецификация (из `docs/dev/spec_v1alpha3.md`)

### Цель
Проставить свойству `rvr.status.config.nodeId` уникальное значение среди всех реплик одной RV, в диапазоне [0; 7].

В случае превышения количества реплик, повторять реконсайл с ошибкой.

### Триггер
- `CREATE(RVR, status.config.nodeId==nil)`

### Вывод
- `rvr.status.config.nodeId`

---

## Код, соответствующий спецификации

### ✅ `controller.go` - Триггеры

**Соответствует спецификации:**
- `CreateFunc` (строки 36-50): Обрабатывает `CREATE(RVR, status.config.nodeId==nil)`
  - Проверяет, что `nodeId` не установлен
  - Добавляет запрос в очередь

**Добавлено сверх спецификации (стандартная практика controller-runtime):**
- `GenericFunc` (строки 66-81): Обрабатывает синхронизацию при старте контроллера
  - Это стандартная практика для reconciliation на старте
  - Не указано в спецификации, но необходимо для корректной работы

**Не требуется спецификацией:**
- `UpdateFunc` (строки 52-58): No-op, так как `nodeId` неизменяем после установки
- `DeleteFunc` (строки 59-65): No-op, так как удаление не требует присвоения `nodeId`

### ✅ `reconciler.go` - Основная логика

**Соответствует спецификации:**

1. **Присвоение уникального `nodeId` в диапазоне [0; 7]** (строки 131-138)
   ```go
   // Find available nodeID
   var availableNodeID *uint
   for i := uint(minNodeID); i <= uint(maxNodeID); i++ {
       if !usedNodeIDs[i] {
           availableNodeID = &i
           break
       }
   }
   ```

2. **Проверка превышения количества реплик** (строки 106-128)
   ```go
   if totalReplicas > maxNodeID+1 {
       return reconcile.Result{}, e.ErrInvalidClusterf(...)
   }
   ```
   - Возвращает ошибку `ErrInvalidCluster`, что приводит к повторному reconcile

3. **Установка `rvr.status.config.nodeId`** (строки 178-207)
   - Использует `PatchStatusWithConflictRetry` для обновления статуса
   - Устанавливает `currentRVR.Status.Config.NodeId = availableNodeID`

4. **Сбор занятых `nodeId` среди всех реплик одной RV** (строки 80-104)
   - Получает все RVR для того же `ReplicatedVolumeName`
   - Собирает занятые `nodeId` в диапазоне [0; 7]

5. **Проверка, что `nodeId` еще не установлен** (строки 74-78)
   - Идемпотентность: если уже установлен, выходит без изменений

---

## Код, добавленный сверх спецификации

### ⚠️ `setNodeIDErrorCondition` - Улучшение наблюдаемости

**Файл:** `reconciler.go`, строки 232-276

**Статус:** НЕ в спецификации, добавлено для улучшения наблюдаемости

**Что делает:**
- Устанавливает `ConfigurationAdjusted=False` с `reason=ConfigurationFailed` в RVR status conditions
- Вызывается при ошибках:
  - Слишком много реплик (строка 114)
  - Все `nodeId` заняты (строка 146)
  - Все `nodeId` заняты при retry (строка 210)

**Почему добавлено:**
- Спецификация требует только возвращать ошибку
- Добавлено, чтобы администраторы видели проблему в RVR status conditions, а не только в логах контроллера

**Как откатить:**
- Удалить все вызовы `r.setNodeIDErrorCondition(...)` (строки 114, 146, 210)
- Удалить функцию `setNodeIDErrorCondition` (строки 232-276)
- Оставить только `return reconcile.Result{}, e.ErrInvalidClusterf(...)`

**Комментарии в коде:**
- Строки 109-113: "NOTE: Setting status condition is NOT in the spec..."
- Строки 141-145: "NOTE: Setting status condition is NOT in the spec..."
- Строки 235-241: "NOTE: This function and its usage are NOT in the spec..."

### ⚠️ `PatchStatusWithConflictRetry` - Обработка параллелизма

**Файл:** `reconciler.go`, строки 178-207

**Статус:** Техническая деталь реализации, не указана в спецификации

**Что делает:**
- Использует optimistic locking для безопасной параллельной обработки
- При конфликте (409) перезагружает ресурс и повторяет попытку
- Проверяет внутри `patchFn`, не установлен ли уже `nodeId` (idempotent check)

**Почему добавлено:**
- Спецификация не описывает технические детали обработки параллелизма
- Необходимо для корректной работы при параллельной обработке запросов несколькими воркерами
- Без этого возможны race conditions, когда два воркера присваивают один и тот же `nodeId`

**Соответствие спецификации:**
- ✅ Спецификация требует присвоение уникального `nodeId` - это обеспечивается
- ✅ Спецификация не запрещает использование retry механизмов
- Это техническая деталь реализации, необходимая для корректной работы

### ⚠️ `GenericFunc` - Reconciliation на старте

**Файл:** `controller.go`, строки 66-81

**Статус:** Стандартная практика controller-runtime, не указана в спецификации

**Что делает:**
- Обрабатывает события синхронизации при старте контроллера
- Проверяет все существующие RVR и добавляет в очередь те, у которых `nodeId` не установлен

**Почему добавлено:**
- Стандартная практика для Kubernetes контроллеров
- Обеспечивает обработку RVR, созданных до старта контроллера
- Не указано в спецификации, но необходимо для корректной работы

---

## Итоговая таблица соответствия

| Требование спецификации | Статус | Расположение в коде |
|------------------------|--------|-------------------|
| Присвоение уникального `nodeId` в диапазоне [0; 7] | ✅ Соответствует | `reconciler.go:131-138` |
| Проверка превышения количества реплик | ✅ Соответствует | `reconciler.go:106-128` |
| Возврат ошибки при превышении | ✅ Соответствует | `reconciler.go:123-128` |
| Триггер `CREATE(RVR, status.config.nodeId==nil)` | ✅ Соответствует | `controller.go:36-50` |
| Вывод `rvr.status.config.nodeId` | ✅ Соответствует | `reconciler.go:201` |
| Установка условия ошибки в status | ⚠️ Сверх спецификации | `reconciler.go:232-276` |
| Обработка параллелизма через retry | ⚠️ Техническая деталь | `reconciler.go:178-207` |
| Reconciliation на старте | ⚠️ Стандартная практика | `controller.go:66-81` |

---

## Итоги

1. **Код, соответствующий спецификации:** Оставлен как есть, полностью соответствует требованиям.

2. **Код сверх спецификации:**
   - `setNodeIDErrorCondition`: Можно оставить для улучшения наблюдаемости, или удалить для строгого соответствия спецификации
   - `PatchStatusWithConflictRetry`: Необходимо оставить для корректной работы при параллелизме
   - `GenericFunc`: Необходимо оставить для стандартной работы контроллера


