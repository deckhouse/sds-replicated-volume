# Соответствие спецификации для `rv-status-config-device-minor-controller`

> **Примечание:** Этот контроллер соответствует стандартам проекта, описанным в [`CONTROLLER_STYLE_GUIDE.md`](../CONTROLLER_STYLE_GUIDE.md).

## Спецификация (из `docs/dev/spec_v1alpha3.md`)

### Цель
Инициализировать свойство `rv.status.config.deviceMinor` минимальным свободным значением среди всех RV.

По завершению работы контроллера у каждой RV должен быть свой уникальный `rv.status.config.deviceMinor`.

### Триггер
- `CREATE/UPDATE(RV, rv.status.config.deviceMinor == nil)` (в спецификации указано `!= nil`, но это опечатка - должно быть `== nil` или проверка на отсутствие Config)

### Вывод
- `rv.status.config.deviceMinor`

---

## Схема логики работы контроллера

```
┌──────────────────────────────────────────────────────────────────┐
│                    Триггеры контроллера                          │
├──────────────────────────────────────────────────────────────────┤
│ CREATE/UPDATE(RV, status.config == nil)                          │
└──────────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Reconcile()                                │
├─────────────────────────────────────────────────────────────────┤
│ 1. Получить RV по req.NamespacedName                            │
│ 2. Проверить: deviceMinor уже установлен?                       │
└─────────────────────────────────────────────────────────────────┘
                            │
                ┌───────────┴───────────┐
                │                       │
                ▼                       ▼
    ┌───────────────────┐   ┌──────────────────────────┐
    │ deviceMinor       │   │ deviceMinor не установлен│
    │ установлен        │   │ (Config==nil)            │
    └───────────────────┘   └──────────────────────────┘
                │                       │
                ▼                       ▼
    ┌────────────────────┐   ┌──────────────────────────────┐
    │ return (idempotent)│   │ Получить все RV              │
    └────────────────────┘   └──────────────────────────────┘
                                        │
                                        ▼
                            ┌──────────────────────────────┐
                            │ Собрать занятые deviceMinors │
                            │ (0-1048575)                  │
                            └──────────────────────────────┘
                                        │
                                        ▼
                            ┌──────────────────────────────┐
                            │ Найти минимальный свободный  │
                            │ deviceMinor (заполняя        │
                            │ пропуски)                    │
                            └──────────────────────────────┘
                                        │
                                        ▼
                            ┌──────────────────────────────┐
                            │ PatchStatusWithConflictRetry │
                            │ 1. Проверить deviceMinor     │
                            │    снова (idempotent check)  │
                            │ 2. Инициализировать status   │
                            │    если нужно                │
                            │ 3. Установить deviceMinor    │
                            └──────────────────────────────┘
                                        │
                                        ▼
                            ┌──────────────────────────────┐
                            │ return (success)             │
                            └──────────────────────────────┘
```

### Описание схемы

**Триггеры:**
- `CREATE/UPDATE(RV)` без `Config` (Status == nil или Status.Config == nil) → запускает присвоение уникального `deviceMinor`
- **Важно:** Поскольку `DeviceMinor` имеет тип `uint` (не указатель), мы не можем проверить на `nil`. Если `Config` существует, считаем `deviceMinor` установленным, даже если значение = 0 (так как 0 - валидное значение для deviceMinor)

**Основной поток:**
1. **Идемпотентная проверка:** Если `deviceMinor` уже установлен (Config существует и deviceMinor в валидном диапазоне), выходим без изменений
2. **Сбор информации:** Получаем все RV и собираем занятые `deviceMinor` (0-1048575)
3. **Поиск минимального свободного deviceMinor:** Ищем первый свободный `deviceMinor` в диапазоне [0; 1048575], заполняя пропуски
4. **Установка deviceMinor:** Используем `PatchStatusWithConflictRetry` для безопасной установки с повторной проверкой внутри `patchFn`

**Важно: Логика присвоения deviceMinor:**
- **Уникальность:** `deviceMinor` должен быть уникальным среди всех RV в кластере
- **Диапазон:** `deviceMinor` в диапазоне [0; 1048575] (всего 1048576 возможных значений)
  - Значение 1048575 = 2^20 - 1 соответствует максимальному minor number, поддерживаемому современными ядрами Linux (2.6+)
  - DRBD устройства именуются как `/dev/drbd<minor>`, например `/dev/drbd0`, `/dev/drbd1`, и т.д.
  - Этот диапазон позволяет использовать до 1,048,576 уникальных DRBD устройств
  - Соответствует валидации в API (`Maximum=1048575`) и диапазону в `cluster/consts.go` (`MaxNodeMinor = 1048576`, не включительно)
- **Минимальное значение:** Присваивается минимальное свободное значение (заполняются пропуски)
- **Особенность типа:** `DeviceMinor` имеет тип `uint` (не указатель), поэтому нельзя проверить на `nil`. Проверяем наличие `Config` - если `Config` существует, считаем `deviceMinor` установленным (даже если значение = 0, так как 0 - валидное значение)
- **Параллелизм:** Используется `PatchStatusWithConflictRetry` для безопасной обработки параллельных запросов

**Особенности:**
- Идемпотентность: проверки на каждом этапе (в начале `Reconcile` и внутри `patchFn`)
- Безопасность параллелизма: использование `PatchStatusWithConflictRetry` с optimistic locking
- Обработка типа `uint`: Поскольку `DeviceMinor` имеет тип `uint` (не указатель), проверяем наличие `Config` для определения, установлен ли `deviceMinor`

---

## Код, соответствующий спецификации

### ✅ `controller.go` - Триггеры

**Соответствует спецификации:**
- Использует `.For(&v1alpha3.ReplicatedVolume{})` для указания основного ресурса
- `CreateFunc` в `predicate.Funcs` (строки 27-33): Обрабатывает `CREATE(RV, status.config == nil)`
  - Проверяет, что `Config` не существует (Status == nil или Status.Config == nil)
  - Возвращает `true` для обработки события
  - **Важно:** Не проверяет `deviceMinor == 0`, так как если `Config` существует, `deviceMinor` считается установленным (даже если значение = 0)
- `UpdateFunc` в `predicate.Funcs` (строки 34-40): Обрабатывает `UPDATE(RV, status.config == nil)`
  - Проверяет, что `Config` не существует
  - Возвращает `true` для обработки события
  - **Важно:** Не проверяет `deviceMinor == 0`, так как если `Config` существует, `deviceMinor` считается установленным (даже если значение = 0)

**Добавлено сверх спецификации (стандартная практика controller-runtime):**
- `GenericFunc` в `predicate.Funcs` (строки 47-54): Обрабатывает синхронизацию при старте контроллера
  - Это стандартная практика для reconciliation на старте
  - Не указано в спецификации, но необходимо для корректной работы
- Использование `builder.ControllerManagedBy` и `.For()` - соответствует стандартам проекта (см. `CONTROLLER_STYLE_GUIDE.md`)

**Не требуется спецификацией:**
- `DeleteFunc` (строки 43-46): No-op, так как удаление не требует присвоения `deviceMinor`

### ✅ `reconciler.go` - Основная логика

**Соответствует спецификации:**

1. **Использование стандартного `reconcile.Reconciler`** (строки 26, 33-36)
   - Использует стандартный `reconcile.Request` вместо кастомных типов
   - Соответствует стандартам проекта (см. `CONTROLLER_STYLE_GUIDE.md`)

2. **Structured logging** (строка 37)
   - Использует `logr.Logger` с `.WithName()` и `.WithValues()`
   - Соответствует стандартам проекта

3. **Присвоение уникального `deviceMinor` в диапазоне [0; 1048575]** (строки 87-94)
   ```go
   // Find available deviceMinor (minimum free value)
   var availableDeviceMinor uint
   for i := uint(minDeviceMinor); i <= uint(maxDeviceMinor); i++ {
       if !usedDeviceMinors[i] {
           availableDeviceMinor = i
           break
       }
   }
   ```

4. **Установка `rv.status.config.deviceMinor`** (строки 96-147)
   - Использует `PatchStatusWithConflictRetry` для обновления статуса
   - Устанавливает `currentRV.Status.Config.DeviceMinor = availableDeviceMinor`

5. **Сбор занятых `deviceMinor` среди всех RV** (строки 65-87)
   - Получает все RV в кластере
   - Собирает занятые `deviceMinor` в диапазоне [0; 1048575]

6. **Проверка, что `deviceMinor` еще не установлен** (строки 54-63, 71-90)
   - Идемпотентность: если уже установлен, выходит без изменений
   - **Особенность:** Поскольку `DeviceMinor` имеет тип `uint` (не указатель), проверяем наличие `Config` и валидность значения

---

## Код, добавленный сверх спецификации

### ⚠️ `PatchStatusWithConflictRetry` - Обработка параллелизма

**Файл:** `reconciler.go`, строки 96-147

**Статус:** Техническая деталь реализации, не указана в спецификации

**Что делает:**
- Использует optimistic locking для безопасной параллельной обработки
- При конфликте (409) перезагружает ресурс и повторяет попытку
- Проверяет внутри `patchFn`, не установлен ли уже `deviceMinor` (idempotent check)

**Почему добавлено:**
- Спецификация не описывает технические детали обработки параллелизма
- Необходимо для корректной работы при параллельной обработке запросов несколькими воркерами
- Без этого возможны race conditions, когда два воркера присваивают один и тот же `deviceMinor`

**Соответствие спецификации:**
- ✅ Спецификация требует присвоение уникального `deviceMinor` - это обеспечивается
- ✅ Спецификация не запрещает использование retry механизмов
- Это техническая деталь реализации, необходимая для корректной работы

### ⚠️ `GenericFunc` - Reconciliation на старте

**Файл:** `controller.go`, строки 47-54

**Статус:** Стандартная практика controller-runtime, не указана в спецификации

**Что делает:**
- Обрабатывает события синхронизации при старте контроллера
- Проверяет все существующие RV и добавляет в очередь те, у которых `deviceMinor` не установлен

**Почему добавлено:**
- Стандартная практика для Kubernetes контроллеров
- Обеспечивает обработку RV, созданных до старта контроллера
- Не указано в спецификации, но необходимо для корректной работы

### ⚠️ Обработка типа `uint` для `DeviceMinor`

**Файл:** `reconciler.go`, строки 54-63, 71-90

**Статус:** Техническая деталь реализации, связанная с типом поля

**Что делает:**
- Поскольку `DeviceMinor` имеет тип `uint` (не указатель), нельзя проверить на `nil`
- Проверяем наличие `Config` - если `Config` существует, считаем `deviceMinor` установленным
- Проверяем, что `deviceMinor` находится в валидном диапазоне [0; 1048575]

**Почему добавлено:**
- Необходимо для корректной работы с типом `uint`
- Обеспечивает идемпотентность: если `Config` существует, считаем `deviceMinor` установленным

---

## Итоговая таблица соответствия

| Требование спецификации | Статус | Расположение в коде |
|------------------------|--------|-------------------|
| Присвоение уникального `deviceMinor` в диапазоне [0; 1048575] | ✅ Соответствует | `reconciler.go:87-94` |
| Минимальное свободное значение | ✅ Соответствует | `reconciler.go:87-94` |
| Триггер `CREATE/UPDATE(RV, deviceMinor не установлен)` | ✅ Соответствует | `controller.go:27-40` |
| Вывод `rv.status.config.deviceMinor` | ✅ Соответствует | `reconciler.go:142` |
| Обработка параллелизма через retry | ⚠️ Техническая деталь | `reconciler.go:96-147` |
| Reconciliation на старте | ⚠️ Стандартная практика | `controller.go:47-54` |
| Стандартный reconcile.Reconciler | ✅ Соответствует стандартам | `reconciler.go:26, 33-36` |
| Использование .For() | ✅ Соответствует стандартам | `controller.go:25` |
| Structured logging | ✅ Соответствует стандартам | `reconciler.go:37` |
| Тестирование на Ginkgo/Gomega | ✅ Соответствует стандартам | `reconciler_test.go` |

---

## Итоги

1. **Код, соответствующий спецификации:** Оставлен как есть, полностью соответствует требованиям.

2. **Код сверх спецификации:**
   - `PatchStatusWithConflictRetry`: Необходимо оставить для корректной работы при параллелизме
   - `GenericFunc`: Необходимо оставить для стандартной работы контроллера
   - Обработка типа `uint`: Необходимо для корректной работы с типом поля

3. **Тестирование:**
   - Используется **Ginkgo/Gomega** для структурированных тестов (соответствует `CONTROLLER_STYLE_GUIDE.md`)
   - Все тесты переписаны с использованием `Describe`/`It`/`BeforeEach` паттерна
   - Используется `GinkgoLogr` для интеграции логирования с Ginkgo
   - Покрытие: 8 тестов, включая happy path, edge cases, идемпотентность, заполнение пропусков

