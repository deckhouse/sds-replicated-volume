diff --git a/cmd/stork/stork.go b/cmd/stork/stork.go
index 56d343a63..49ae30f98 100644
--- a/cmd/stork/stork.go
+++ b/cmd/stork/stork.go
@@ -264,7 +264,7 @@ func run(c *cli.Context) {

 	verbose := c.Bool("verbose")
 	if verbose {
-		log.SetLevel(log.DebugLevel)
+		log.SetLevel(log.TraceLevel)
 	}

 	config, err := rest.InClusterConfig()
diff --git a/pkg/extender/extender.go b/pkg/extender/extender.go
index 73c8c307a..d1a51ca5c 100644
--- a/pkg/extender/extender.go
+++ b/pkg/extender/extender.go
@@ -3,14 +3,18 @@ package extender
 import (
 	"context"
 	"encoding/json"
+	"errors"
 	"fmt"
 	"net/http"
+	"net/http/httputil"
+	"os"
 	"strconv"
 	"strings"
 	"sync"
 	"time"

 	"github.com/libopenstorage/stork/drivers/volume"
+	storkcache "github.com/libopenstorage/stork/pkg/cache"
 	storklog "github.com/libopenstorage/stork/pkg/log"
 	restore "github.com/libopenstorage/stork/pkg/snapshot/controllers"
 	"github.com/portworx/sched-ops/k8s/core"
@@ -77,6 +81,10 @@ var (
 type Extender struct {
 	Recorder record.EventRecorder
 	Driver   volume.Driver
+	// block added by flant.com
+	CertFile string `json:"cert-file"`
+	KeyFile  string `json:"key-file"`
+	// end of flant.com block
 	server   *http.Server
 	lock     sync.Mutex
 	started  bool
@@ -94,9 +102,34 @@ func (e *Extender) Start() error {
 	e.server = &http.Server{Addr: ":8099"}
 	http.HandleFunc("/", e.serveHTTP)
 	go func() {
-		if err := e.server.ListenAndServe(); err != http.ErrServerClosed {
+		// block added by flant.com
+		err := error(nil)
+		tlsMode := len(e.CertFile) > 0 && len(e.KeyFile) > 0
+
+		if tlsMode {
+			if _, exist := os.Stat(e.CertFile); errors.Is(exist, os.ErrNotExist) {
+				log.Warnf("CertFile `%s` does not exists. Launch as HTTP", e.CertFile)
+				tlsMode = false
+			}
+
+			if _, exist := os.Stat(e.KeyFile); errors.Is(exist, os.ErrNotExist) {
+				log.Warnf("KeyFile `%s` does not exists. Launch as HTTP", e.KeyFile)
+				tlsMode = false
+			}
+		}
+
+		if tlsMode {
+			log.Warn("Starting as HTTPS on :8099")
+			err = e.server.ListenAndServeTLS(e.CertFile, e.KeyFile)
+		} else {
+			log.Warn("Starting as HTTP on :8099")
+			err = e.server.ListenAndServe()
+		}
+
+		if err != http.ErrServerClosed {
 			log.Panicf("Error starting extender server: %v", err)
 		}
+		// end of flant.com block
 	}()

 	prometheus.MustRegister(HyperConvergedPodsCounter)
@@ -149,6 +182,16 @@ func (e *Extender) getHostname(node *v1.Node) string {
 }

 func (e *Extender) processFilterRequest(w http.ResponseWriter, req *http.Request) {
+	// block added by flant.com
+	payload, err := httputil.DumpRequest(req, true)
+	if err != nil {
+		log.Errorf("Error debugging filter request: %v", err)
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+	log.Tracef("[filter] received request: %s", string(payload))
+	// end of flant.com block
+
 	decoder := json.NewDecoder(req.Body)
 	defer func() {
 		if err := req.Body.Close(); err != nil {
@@ -164,6 +207,15 @@ func (e *Extender) processFilterRequest(w http.ResponseWriter, req *http.Request
 		return
 	}

+	// block added by flant.com
+	args, err = fillNodesByNames(args)
+	if err != nil {
+		log.Errorf("Cannot fill nodes: %+v", err)
+		http.Error(w, "Cannot fill nodes", http.StatusBadRequest)
+		return
+	}
+	// end of flant.com block
+
 	pod := args.Pod
 	if pod == nil {
 		msg := "Empty pod received in filter request"
@@ -176,9 +228,20 @@ func (e *Extender) processFilterRequest(w http.ResponseWriter, req *http.Request
 		if vol.PersistentVolumeClaim == nil {
 			continue
 		}
-		pvc, err := core.Instance().GetPersistentVolumeClaim(vol.PersistentVolumeClaim.ClaimName, pod.Namespace)
+
+		var pvc *v1.PersistentVolumeClaim
+		var err error
+		var msg string
+
+		if storkcache.Instance() != nil {
+			pvc, err = storkcache.Instance().GetPersistentVolumeClaim(vol.PersistentVolumeClaim.ClaimName, pod.Namespace)
+			msg = fmt.Sprintf("Unable to find PVC %s in informer cache, err: %v", vol.Name, err)
+		} else {
+			pvc, err = core.Instance().GetPersistentVolumeClaim(vol.PersistentVolumeClaim.ClaimName, pod.Namespace)
+			msg = fmt.Sprintf("Unable to find PVC %s, err: %v", vol.Name, err)
+		}
+
 		if err != nil {
-			msg := fmt.Sprintf("Unable to find PVC %s, err: %v", vol.Name, err)
 			storklog.PodLog(pod).Warnf(msg)
 			e.Recorder.Event(pod, v1.EventTypeWarning, schedulingFailureEventReason, msg)
 			http.Error(w, msg, http.StatusBadRequest)
@@ -192,7 +255,7 @@ func (e *Extender) processFilterRequest(w http.ResponseWriter, req *http.Request
 		}
 	}

-	storklog.PodLog(pod).Debugf("Nodes in filter request:")
+	storklog.PodLog(pod).Debugf("[filter] Nodes in filter request")
 	for _, node := range args.Nodes.Items {
 		storklog.PodLog(pod).Debugf("%v %+v", node.Name, node.Status.Addresses)
 	}
@@ -385,9 +448,27 @@ func (e *Extender) collectExtenderMetrics() error {
 		return nil
 	}

-	if err := core.Instance().WatchPods("", fn, metav1.ListOptions{}); err != nil {
-		log.Errorf("failed to watch pods due to: %v", err)
-		return err
+	podHandler := func(object interface{}) {
+		pod, ok := object.(*v1.Pod)
+		if !ok {
+			log.Errorf("invalid object type on pod watch from cache: %v", object)
+		} else {
+			fn(pod)
+		}
+	}
+
+	if storkcache.Instance() != nil {
+		log.Debugf("Shared informer cache has been initialized, using it for extender metrics.")
+		err := storkcache.Instance().WatchPods(podHandler)
+		if err != nil {
+			log.Errorf("failed to watch pods with informer cache for health monitoring, err: %v", err)
+		}
+	} else {
+		log.Warnf("Shared informer cache has not been initialized, using watch for extender metrics.")
+		if err := core.Instance().WatchPods("", fn, metav1.ListOptions{}); err != nil {
+			log.Errorf("failed to watch pods for metrics due to: %v", err)
+			return err
+		}
 	}
 	return nil
 }
@@ -632,3 +713,43 @@ sendResponse:
 		storklog.PodLog(pod).Errorf("Failed to encode response: %v", err)
 	}
 }
+
+// block added by flant.com
+func fillNodesByNames(inputData schedulerapi.ExtenderArgs) (schedulerapi.ExtenderArgs, error) {
+	if inputData.NodeNames != nil && len(*inputData.NodeNames) > 0 {
+		if inputData.Nodes != nil && len(inputData.Nodes.Items) > 0 {
+			// nodes already presents in inputData
+			return inputData, nil
+		}
+	} else {
+		// return same nodes in case there is no NodeNames present
+		return inputData, fmt.Errorf("no NodeNames")
+	}
+
+	var node *v1.Node
+	var err error
+	var msg string
+
+	nodeList := &v1.NodeList{}
+
+	for _, nodeName := range *inputData.NodeNames {
+		if storkcache.Instance() != nil {
+			node, err = storkcache.Instance().GetNode(nodeName)
+			msg = fmt.Sprintf("Unable to get node info for node %s from informer cache, err: %v", nodeName, err)
+		} else {
+			node, err = core.Instance().GetNodeByName(nodeName)
+			msg = fmt.Sprintf("Unable to get node info for node %s, err: %v", nodeName, err)
+		}
+
+		if err != nil {
+			// log.Errorf("Error getting node %v: %v", k8sNodeName, err)
+			return inputData, fmt.Errorf(msg)
+		}
+
+		nodeList.Items = append(nodeList.Items, *node)
+	}
+
+	inputData.Nodes = nodeList
+	return inputData, nil
+}
+// end of flant.com block
