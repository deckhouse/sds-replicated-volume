---
globs: images/controller/internal/controllers/rv_controller/reconciler*.go,images/controller/internal/controllers/rv_attach_controller/reconciler*.go
alwaysApply: false
---

See `rfc-like-mdc.mdc` for normative keywords (BCP 14 / RFC 2119 / RFC 8174) and general .mdc writing conventions.

# DeleteReconcileHelper

This document defines naming and contracts for **DeleteReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **DeleteReconcileHelpers** (`delete<Kind>`) are **single-call I/O helpers**: they perform exactly **one** **Kubernetes API I/O** write — `Delete(...)` — for exactly one **object** (or treat NotFound as “already absent”, depending on policy).
- They MUST NOT perform any other **Kubernetes API I/O** calls (`Get/List/Create/Update/Patch`), MUST NOT call **DeepCopy**, and MUST NOT execute patches or make **patch ordering** / **patch type decision** decisions.
- They MUST NOT mutate the **object** as part of deletion (no “marking”, no finalizer edits, no status writes — no publishing **report** and no persisting **controller-owned state**); any prerequisite mutations (e.g., finalizer removal) are done by **Reconcile methods** via a **separate** ensure/apply + patch step **before** calling delete.
- Everything they control MUST be deterministic (no time/random/env-driven behavior; consistent NotFound handling).

---

## Definition

A **DeleteReconcileHelper** (“delete helper”) is a **ReconcileHelper** that is:

- **allowed to perform I/O**, and
- deletes exactly **one** Kubernetes object via the API (or ensures it is absent), and
- returns the delete outcome (and optionally an error).

Typical delete helpers encapsulate the mechanical delete call (including “already gone” handling) for child resources, while **Reconcile methods** decide ordering relative to other actions.

---

## Naming

- A **DeleteReconcileHelper** name MUST start with `delete` / `Delete`.
- **DeleteReconcileHelpers** for Kubernetes **objects** MUST use the form: `delete<Kind>` / `Delete<Kind>`. `<Kind>` MUST either correspond to the Kubernetes **object** kind being deleted or be a short kind name that is already established in the codebase. Examples:
  - `deleteCM(...)` (or `deleteConfigMap(...)`)
  - `deleteSVC(...)` (or `deleteService(...)`)
  - `deleteSKN(...)` (or `deleteSomeKindName(...)`)
- **DeleteReconcileHelpers** names MUST NOT imply orchestration or multi-step cleanup (`reconcileDelete`, `deleteAll`, `deleteAndWait`) — ordering and lifecycle policy belong to **Reconcile methods**.

---

## Preferred signatures

- For **DeleteReconcileHelpers** (`delete*`), the simplest signature from the variants below that preserves explicit dependencies and a single-API-call scope SHOULD be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they MAY also be used.

### Simple delete
```go
func (r *Reconciler) deleteSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
) flow.Outcome
```

Or, if **Outcome** (in code, the type is `flow.Outcome`) is intentionally not used:
```go
func (r *Reconciler) deleteSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
) error
```

---

## Receivers

- **DeleteReconcileHelpers** MUST be methods on `Reconciler` (they perform I/O via controller-runtime client owned by `Reconciler`).

---

## I/O boundaries

**DeleteReconcileHelpers** MAY do the following:

- controller-runtime client usage to execute exactly **one** Kubernetes API call: `Delete(...)`.

**DeleteReconcileHelpers** MUST NOT do any of the following:

- Kubernetes API calls other than that single `Delete(...)` (no `Get/List/Create/Update/Patch`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- performing any other I/O besides the single Kubernetes API request they own.

**DeleteReconcileHelpers** MUST NOT do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind **other than** the single Kubernetes API request they own.

> Rationale: delete helpers are mechanical wrappers around exactly one delete operation; ordering and lifecycle policy remain explicit in **Reconcile methods**.

---

## Determinism contract

A **DeleteReconcileHelper** MUST be **deterministic** in everything it controls.

In particular:
- It MUST issue a single, mechanical delete operation with behavior determined only by explicit inputs.
- It MUST NOT introduce “hidden I/O” (time, random, env, extra network calls) beyond the single Kubernetes API `Delete(...)` request they own.
- It MUST NOT contain business-logic branching that depends on nondeterministic inputs.
- See the common determinism contract in `controller-reconcile-helper.mdc` (ordering stability, no map iteration order reliance).

> Practical reason: delete should be a predictable mechanical operation; nondeterminism leads to flaky cleanup paths.

---

## Read-only contract

`delete<Kind>` / `Delete<Kind>` MUST treat inputs as read-only:

- it MUST NOT mutate input objects (including the object being deleted);
- it MUST NOT perform in-place modifications through aliases.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- A **DeleteReconcileHelper** MUST perform exactly one API write: `Delete(...)`.
- It MUST NOT modify either patch domain (main or status) as part of deletion:
  - no “prepare for delete” patches (e.g., finalizer removal);
  - no status updates/patches.
- If deletion requires preliminary changes (e.g., removing a finalizer), those changes MUST be performed by **Reconcile methods** via separate ensure/apply + patch steps **before** calling the delete helper.

---

## Composition

- A **DeleteReconcileHelper** MUST perform exactly one API write (`Delete(...)`) for exactly one object.
- Any prerequisite mutations (e.g., removing finalizers) MUST be composed in **Reconcile methods** (ensure/apply + patch) and MUST NOT be hidden inside the delete helper.
- If multiple objects must be deleted (loops, groups, fan-out), that orchestration MUST live in **Reconcile methods**; delete helpers must remain single-object.
- A **DeleteReconcileHelper** MUST NOT call other **ReconcileHelpers**.

---

## Flow phases and **Outcome**

- **DeleteReconcileHelpers** MUST NOT create a `reconcile/flow` **phase** — they should stay mechanical and short.
- If a **DeleteReconcileHelper** returns **Outcome** (in code: `flow.Outcome`), it SHOULD use helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.
  - Prefer encoding retry/requeue policy explicitly in the returned **Outcome**.

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- A **DeleteReconcileHelper** SHOULD be mechanically thin: if the single `Delete(...)` call fails, return the error **without wrapping** (or treat NotFound per the chosen deterministic policy).
  - If returning **Outcome** (in code: `flow.Outcome`), use `flow.Fail(err)` (or equivalent) with the original `err`.
- A **DeleteReconcileHelper** MUST NOT enrich errors with additional context (including **object identity** such as `namespace/name`, UID, object key).
  - Error enrichment (action + **object identity** + **phase**) is the calling **Reconcile method**’s responsibility.

---

## Common anti-patterns (MUST NOT)

❌ Doing existence checks (`Get/List`) or any extra Kubernetes API calls:
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) flow.Outcome {
    // forbidden: extra API call
    var existing v1alpha1.EON
    if err := r.client.Get(ctx, client.ObjectKeyFromObject(obj), &existing); err != nil {
        return flow.Fail(err)
    }

    // forbidden: second API call in the same helper
    if err := r.client.Delete(ctx, &existing); err != nil {
        return flow.Fail(err)
    }
    return flow.Continue()
}
```

❌ Performing more than one write (`Delete` + `Patch/Update/Create`, retries-as-extra-calls, fallback logic):
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    if err := r.client.Delete(ctx, obj); err != nil {
        // forbidden: "fallback" write makes it >1 API call
        return r.client.Patch(ctx, obj, client.MergeFrom(obj.DeepCopy()))
    }
    return nil
}
```

❌ Mutating the object as part of deletion (“marking”, finalizer edits, status writes):
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    obj.Finalizers = nil          // forbidden: mutation belongs to ensure/apply + patch
    obj.Status.Phase = "Deleting" // forbidden: status writes (report/controller-owned state) belong elsewhere
    return r.client.Delete(ctx, obj)
}
```

❌ Trying to “prepare for delete” inside the delete helper (remove finalizer + delete):
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    // forbidden: any patch/update belongs to Reconcile methods and is a separate patch domain write
    base := obj.DeepCopy()      // also forbidden: DeepCopy in delete helper
    obj.Finalizers = []string{} // forbidden: mutation
    if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // forbidden: extra write
        return err
    }
    return r.client.Delete(ctx, obj)
}
```

❌ Calling `DeepCopy` inside delete helpers:
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    return r.client.Delete(ctx, obj)
}
```

❌ Deleting multiple objects in a single delete helper:
```go
func (r *Reconciler) deleteEONs(ctx context.Context, objs []*v1alpha1.EON) error {
    for _, obj := range objs {
        if err := r.client.Delete(ctx, obj); err != nil { // forbidden: multiple API calls
            return err
        }
    }
    return nil
}
```

❌ Hidden I/O / nondeterminism (time/random/env/extra network calls):
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    if os.Getenv("DELETE_FAST") == "1" { // forbidden: env read in helper
        // ...
    }
    _ = time.Now() // forbidden
    return r.client.Delete(ctx, obj)
}
```

❌ Using `DeleteAllOf` or broad deletes from a delete helper:
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    // forbidden: not “exactly one object delete”
    return r.client.DeleteAllOf(ctx, &v1alpha1.EON{}, client.InNamespace(obj.Namespace))
}
```

❌ Doing “wait until gone” polling inside the delete helper:
```go
func (r *Reconciler) deleteEON(ctx context.Context, obj *v1alpha1.EON) error {
    if err := r.client.Delete(ctx, obj); err != nil {
        return err
    }

    // forbidden: extra API calls / orchestration belongs to Reconcile methods
    for {
        var cur v1alpha1.EON
        err := r.client.Get(ctx, client.ObjectKeyFromObject(obj), &cur)
        if apierrors.IsNotFound(err) {
            return nil
        }
        if err != nil {
            return err
        }
        time.Sleep(100 * time.Millisecond) // forbidden: time-based hidden I/O
    }
}
```
