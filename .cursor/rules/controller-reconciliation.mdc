---
globs: images/controller/internal/controllers/rv_controller/reconciler*.go,images/controller/internal/controllers/rv_attach_controller/reconciler*.go
alwaysApply: false
---

# Controller reconciliation orchestration (Reconcile methods)

See `rfc-like-mdc.mdc` for normative keywords (BCP 14 / RFC 2119 / RFC 8174) and general .mdc writing conventions.

This document complements `controller-reconcile-helper*.mdc` and defines rules that are **owned by Reconcile methods**
(the orchestration layer), not by helper categories and not by `internal/reconciliation/flow` usage.

---

## Terminology

> Terms like “main resource”, “status subresource”, and patch-domain boundaries are defined in
> `controller-reconcile-helper*.mdc`.
> This document defines only orchestration-specific terminology.

- **Reconcile method**: any function/method named `Reconcile*` / `reconcile*` that orchestrates reconciliation
  (root entrypoint, group reconciler, per-object reconciler, etc.).
- **Patch request**: one API write that persists drift for a single patch domain
  (typically executed by a `patch*` / `patch*Status` helper).
- **Patch base (`base`)**: the `DeepCopy()` snapshot used as a diff reference for **one** patch request.

## Core invariants for Reconcile methods (MUST)

### Phases for Reconcile methods (MUST)

- Any **non-root Reconcile method** **MUST** start a **phase** (`flow.BeginPhase` / `flow.EndPhase`) and return **Outcome**.
- The **root Reconcile** is the only exception: it **MUST** use `flow.Begin(ctx)` (no phases) and return via `outcome.ToCtrl()`.
- See: `controller-reconciliation-flow.mdc`.

### One Reconcile method = one reconciliation pattern (MUST)

- A single Reconcile method **MUST** choose exactly **one** pattern from **“Reconciliation patterns”** below
  and apply it consistently for all changes it performs (across any domains it touches).
- A single Reconcile method **MUST NOT** mix patterns within itself.
- If different parts of reconciliation naturally need different patterns, split the logic into **multiple**
  Reconcile methods (e.g., `reconcileMain(...)` and `reconcileStatus(...)`), each with its own pattern.

### Pattern documentation is mandatory (MUST)

- The selected pattern **MUST** be documented in the GoDoc comment of the Reconcile method entrypoint using
  a single stable style with exact key and order:

  - `Reconcile pattern:` `<PatternName>`

  Example (required format):
  - `// Reconcile pattern: Conditional desired evaluation`

---

## Patch sequencing policy

Reconcile methods **MUST** be the only place that decides:
- whether a patch request is needed;
- the order of multiple patch requests (including main vs status sequencing);
- how outcomes/errors from multiple sub-steps are aggregated;
- where child reconciliation calls are placed relative to patching.

Single-call API writes may be delegated to helpers, but **the sequencing policy lives here**.

---

## DeepCopy & patch-base rules

### DeepCopy is per patch request

- For every patch request, the Reconcile method **MUST** create **exactly one**
  patch base via `obj.DeepCopy()` **immediately before** the object is mutated in that **patch domain** (and then used for the subsequent patch request).
- The patch base variable name **MUST** be `base`.

If a Reconcile method performs multiple patch requests:

- it **MUST** create multiple `base` objects (one per patch request);
- each `base` **MUST** be taken from the object state **immediately before** that **patch domain** is mutated for that specific patch request;
- after patch #1 updates the object, patch #2 **MUST** take `base` from the updated object
  to preserve correct diff and `resourceVersion`.

Go note (no extra lexical scopes required):

```go
var base *ObjT


base = obj.DeepCopy()

// ApplyReconcileHelpers (or EnsureReconcileHelpers) bring `obj` to the intended in-memory state for this patch domain.
applyMainLabels(obj, targetLabels)
applyMainSpec(obj, targetSpec)

if err := patchObj(ctx, obj, base); err != nil {
    return err
}

base = obj.DeepCopy()

// ApplyReconcileHelpers (or EnsureReconcileHelpers) bring `obj` to the intended in-memory state for this patch domain.
applyStatusReport(obj, report)
applyStatusConditions(obj, reportConditions)

if err := patchObjStatus(ctx, obj, base); err != nil {
    return err
}
```

### `base` is a read-only diff reference (MUST)

- Reconcile methods **MUST NOT** mutate `base`
  (directly or through map/slice aliasing).

---

## Object identity & list reconciliation (MUST)

### Lists MUST be reconciled via pointers to list items (MUST)

When reconciling objects from a `List`, you **MUST** take pointers to the actual list elements.

GOOD:
```go
for i := range list.Items {
    obj := &list.Items[i]
}
```

BAD:
```go
for _, obj := range list.Items {
}
```

### Local slices after Create/Patch (MUST)

If a Reconcile method creates objects and keeps a local slice/list for subsequent logic,
it **MUST** append/insert the created objects in their final in-memory state
(including updated `resourceVersion`, defaults, and generated fields).

---

## Reconciliation patterns (MUST)

### Pattern selection rule (MUST)

- Each **Reconcile method** **MUST** choose exactly one pattern.
- The choice **MUST** be documented in GoDoc.

### Pattern 1: In-place reconciliation

ObjCopy → Ensure #1 → Ensure #2 → ... → if changed → Patch

Use when reconciliation is naturally step-by-step and imperative.

### Pattern 2 (default): Target-state driven

ComputeTarget #1 → ComputeTarget #2 → ... → if !all isInSync → ObjCopy → Apply those not InSync → Patch

Use when computing the target is cheap/necessary and the up-to-date check naturally depends on the computed target.

### Pattern 3: Conditional desired evaluation

if ! isInSync → ObjCopy → Ensure OR (ComputeTarget + Apply) → Patch

Use when it is easy to check up-to-date equality without computing state.

### Pattern 4: Pure orchestration

reconcile #1 → reconcile #2 → ... → reconcile #N

Use when the **Reconcile method** is a thin orchestrator that delegates all work to other **Reconcile methods**, and does not implement **domain/business** logic itself (except basic object loading and delegation).

---

## Mixing patterns (FORBIDDEN) (MUST)

Forbidden within one Reconcile method:

- main uses Pattern 3, status uses Pattern 1;
- main uses Pattern 2, status uses Pattern 3.

Allowed:

- same pattern for all domains;
- split into multiple Reconcile methods, each with its own pattern.

---

## Child resources and decomposition (MUST)

- Child resources **SHOULD** be reconciled in separate Reconcile methods:
  - group reconciler (list + ordering);
  - per-object reconciler.
- Prefer passing already loaded objects.
- Always pass pointers from list iteration.
- Caller owns ordering relative to patching.

---

## Business logic failures & requeue policy (MUST)

- Business-logic blocking conditions **MUST** return an error.
- Exception: if unblocked by watched resources, returning “done / no-op” is acceptable.
- If unblocked by **unwatched** events:
  - return an error, or
  - requeue only with clear justification and visible status signal.

---

## objutilv1 usage (MUST)

All work with:

- labels,
- annotations,
- finalizers,
- owner references,
- conditions

**MUST** go through `objutilv1`, imported as `obju`.

Manual manipulation is forbidden unless `objutilv1` is extended.
