---
description: Controller reconciliation orchestration (Reconcile methods)
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# Controller reconciliation orchestration (Reconcile methods)

This document complements `controller-reconcile-helper*.mdc` and defines rules that are **owned by Reconcile methods**
(orchestration layer) rather than by individual ReconcileHelper categories.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## Terminology (MUST)

> Terms like “main resource”, “status subresource”, and patch-domain boundaries are defined in `controller-reconcile-helper*.mdc`.
> This document defines only orchestration-specific terminology.

- **Reconcile method**: any function/method named `Reconcile*` / `reconcile*` that orchestrates reconciliation
  (root entrypoint, group reconciler, per-object reconciler, etc.).
- **Patch request**: one API write that persists drift for a single patch domain
  (typically executed by a `patch*` / `patch*Status` helper).
- **Patch base (`base`)**: the `DeepCopy()` snapshot used as a diff reference for **one** patch request.

---

## Core invariants for Reconcile methods (MUST)

### One Reconcile method = one reconciliation pattern (MUST)

- A single Reconcile method **MUST** choose exactly **one** pattern from **“Reconciliation patterns”** below
  and apply it consistently for all changes it performs (across any domains it touches).
- A single Reconcile method **MUST NOT** mix patterns within itself.
- If different parts of reconciliation naturally need different patterns, split the logic into **multiple**
  Reconcile methods (e.g., `reconcileMain(...)` and `reconcileStatus(...)`), each with its own pattern.

### Pattern documentation is mandatory (MUST)

- The selected pattern **MUST** be documented in the GoDoc comment of the Reconcile method entrypoint using
  a single stable style with exact key and order:

  - `Reconcile pattern:` `<PatternName>`

  Example (required format):
  - `// Reconcile pattern: Conditional desired evaluation`

### Patch sequencing decisions live in Reconcile methods (MUST)

Reconcile methods **MUST** be the only place that decides:
- whether a patch request is needed;
- the order of multiple patch requests (including main vs status sequencing);
- how to aggregate outcomes/errors across multiple sub-steps;
- where to place child reconciliation calls relative to patching.

(Actual single-call API writes may be delegated to single-call I/O helpers; the sequencing policy still lives here.)

---

## DeepCopy & patch-base rules (MUST)

### DeepCopy is per patch request (MUST)

- For every patch request, the Reconcile method **MUST** create **exactly one** patch base via `obj.DeepCopy()`
  **immediately before** that patch request.
- The patch base variable name **MUST** be `base`.

If a Reconcile method performs multiple patch requests:
- it **MUST** create multiple `base` objects (one per patch request);
- each `base` **MUST** be taken from the object state **immediately before** that specific patch;
- after patch #1 updates the object, patch #2 **MUST** take `base` from the updated object
  to preserve correct diff and `resourceVersion`.

Go note (no extra lexical scopes required):
- declare once and reassign right before each patch:
  - `var base *ObjT`
  - `base = obj.DeepCopy()` (immediately before each patch)

### `base` is a read-only diff reference (MUST)

- Reconcile methods **MUST NOT** mutate `base` (directly or through map/slice aliasing).

---

## Object identity & list reconciliation (MUST)

### Lists MUST be reconciled via pointers to list items (MUST)

When reconciling objects from a `List`, you **MUST** take pointers to the actual list elements:

GOOD:
for i := range list.Items {
    obj := &list.Items[i]
}

BAD:
for _, obj := range list.Items {
}

### Local slices after Create/Patch (MUST)

If a Reconcile method creates objects and keeps a local slice/list for subsequent logic,
it **MUST** append/insert the created objects in their final in-memory state
(including updated `resourceVersion`, defaults, generated fields).

---

## Phases (`internal/reconciliation/flow`) (MUST)

### Root phase (MUST)

- Every top-level controller-runtime `Reconcile(...)` **MUST** start with `flow.Begin(ctx)`
  and then use the logger carried in the returned context.

### Every non-root Reconcile method starts a phase (MUST)

- Any Reconcile method other than the top-level `Reconcile(...)` entrypoint
  **MUST** begin with `flow.BeginPhase(...)`.

### Sub-steps and phase boundaries (MUST/SHOULD)

- Most Reconcile methods **SHOULD** use a single phase.
- If decomposed into multiple sub-steps, each sub-step **MUST** start with
  `flow.BeginPhase(ctx, "<phaseName>", ...)` and use the returned `ctx`.

### Phase naming (MUST)

`phaseName` **MUST**:
- be non-empty;
- contain no spaces or control characters;
- optionally use `/` for nesting (no empty segments, no trailing slash);
- use only ASCII letters, digits, `.`, `_`, `-`.

### Return style & aggregation (MUST)

- Sub-steps **SHOULD** return `flow.Outcome`:
  - `flow.Continue()`
  - `flow.ContinueErr(err)` / `flow.ContinueErrf(err, ...)`
  - `flow.Done()`
  - `flow.Fail(err)` / `flow.Failf(err, ...)`
  - `flow.RequeueAfter(d)`
- Aggregation **MUST** use `flow.Merge(...)`:
  - errors joined via `errors.Join`;
  - minimum delay chosen from multiple `RequeueAfter`.
- Top-level `Reconcile(...)` **MUST** return `outcome.ToCtrl()`.

---

## Logger & context passing conventions (MUST)

- Logger **MUST** be carried in `ctx`.
- Functions that log **MUST** accept `ctx context.Context`.
- Do **NOT** pass a logger separately.
- Logger variable name **MUST** be `l`.
- Standard extraction:
  - `l := log.FromContext(ctx)`
- If a phase is started, use the returned `ctx`.

- `ctx` argument position:
  - if present, it **MUST** be the first argument.

---

## Reconciliation patterns (MUST)

### Pattern selection rule (MUST)

- Each Reconcile method **MUST** choose exactly one pattern.
- The choice **MUST** be documented in GoDoc.

### Pattern 1: In-place reconciliation

Ensure/Mutate → Detect → Patch

Use when reconciliation is naturally step-by-step and imperative.

### Pattern 2: Desired-state driven

computeDesired → isUpToDate → apply → patch

Use when desired state is compact and comparison is trivial.

### Pattern 3 (default): Conditional desired evaluation

computeDesiredIfNeeded → apply → patch

Default declarative style; avoids `DeepCopy` when no patch is needed.

---

## Mixing patterns (FORBIDDEN) (MUST)

Forbidden within one Reconcile method:
- main uses Pattern 3, status uses Pattern 1;
- main uses Pattern 2, status uses Pattern 3.

Allowed:
- same pattern for all domains;
- split into multiple Reconcile methods, each with its own pattern.

---

## Child resources and decomposition (MUST)

- Child resources **SHOULD** be reconciled in separate Reconcile methods:
  - group reconciler (list + ordering);
  - per-object reconciler.
- Prefer passing already loaded objects.
- Always pass pointers from list iteration.
- Caller owns ordering relative to patching.

---

## Business logic failures & requeue policy (MUST)

- Business-logic blocking conditions **MUST** return an error.
- Exception: if unblocked by watched resources, `flow.Done()` is acceptable.
- If unblocked by **unwatched** events:
  - return an error, or
  - use `flow.RequeueAfter(d)` only with clear justification and status.

---

## Error wrapping & context (MUST)

- Errors propagated upward **MUST** be wrapped with context.
- Prefer `flow.Failf` / `flow.ContinueErrf`.
- Include action + resource identity.
- Context-free errors are forbidden.

---

## API helpers vs controller business logic (MUST)

- Mechanical helpers (`Get/Set/Has`) **MUST** live on API types.
- No business decisions in API helpers.
- Business logic stays in Reconcile methods and ReconcileHelpers.

---

## objutilv1 usage (MUST)

All work with:
- labels,
- annotations,
- finalizers,
- owner references,
- conditions

**MUST** go through `objutilv1`, imported as `obju`.

Manual manipulation is forbidden unless `objutilv1` is extended.

---

## Review checklist (MUST)

- Each Reconcile method documents its pattern.
- No pattern mixing within one Reconcile method.
- Exactly one `DeepCopy()` per patch request, named `base`.
- Phases started correctly and `ctx` propagated.
- List iteration uses pointers.
- Business-logic blocks return errors unless unblocked by watched events.
- Errors carry context.
- Standard metadata only via `objutilv1`.
