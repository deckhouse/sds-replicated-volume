---
description: Controller reconciliation orchestration (Reconcile methods)
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# Controller reconciliation orchestration (Reconcile methods)

This document complements `controller-reconcile-helper*.mdc` and defines rules that are **owned by Reconcile methods**
(the orchestration layer), not by helper categories and not by `internal/reconciliation/flow` usage.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## Terminology (MUST)

> Terms like “main resource”, “status subresource”, and patch-domain boundaries are defined in
> `controller-reconcile-helper*.mdc`.
> This document defines only orchestration-specific terminology.

- **Reconcile method**: any function/method named `Reconcile*` / `reconcile*` that orchestrates reconciliation
  (root entrypoint, group reconciler, per-object reconciler, etc.).
- **Patch request**: one API write that persists drift for a single patch domain
  (typically executed by a `patch*` / `patch*Status` helper).
- **Patch base (`base`)**: the `DeepCopy()` snapshot used as a diff reference for **one** patch request.

---

## Core invariants for Reconcile methods (MUST)

### One Reconcile method = one reconciliation pattern (MUST)

- A single Reconcile method **MUST** choose exactly **one** pattern from **“Reconciliation patterns”** below
  and apply it consistently for all changes it performs (across any domains it touches).
- A single Reconcile method **MUST NOT** mix patterns within itself.
- If different parts of reconciliation naturally need different patterns, split the logic into **multiple**
  Reconcile methods (e.g., `reconcileMain(...)` and `reconcileStatus(...)`), each with its own pattern.

### Pattern documentation is mandatory (MUST)

- The selected pattern **MUST** be documented in the GoDoc comment of the Reconcile method entrypoint using
  a single stable style with exact key and order:

  - `Reconcile pattern:` `<PatternName>`

  Example (required format):
  - `// Reconcile pattern: Conditional desired evaluation`

---

## Patch sequencing policy (MUST)

Reconcile methods **MUST** be the only place that decides:

- whether a patch request is needed;
- the order of multiple patch requests (including main vs status sequencing);
- how outcomes/errors from multiple sub-steps are aggregated;
- where child reconciliation calls are placed relative to patching.

Single-call API writes may be delegated to helpers, but **the sequencing policy lives here**.

---

## DeepCopy & patch-base rules (MUST)

### DeepCopy is per patch request (MUST)

- For every patch request, the Reconcile method **MUST** create **exactly one**
  patch base via `obj.DeepCopy()` **immediately before** that patch request.
- The patch base variable name **MUST** be `base`.

If a Reconcile method performs multiple patch requests:

- it **MUST** create multiple `base` objects (one per patch request);
- each `base` **MUST** be taken from the object state **immediately before** that specific patch;
- after patch #1 updates the object, patch #2 **MUST** take `base` from the updated object
  to preserve correct diff and `resourceVersion`.

Go note (no extra lexical scopes required):

```go
var base *ObjT
base = obj.DeepCopy() // immediately before each patch
```

### `base` is a read-only diff reference (MUST)

- Reconcile methods **MUST NOT** mutate `base`
  (directly or through map/slice aliasing).

---

## Object identity & list reconciliation (MUST)

### Lists MUST be reconciled via pointers to list items (MUST)

When reconciling objects from a `List`, you **MUST** take pointers to the actual list elements.

GOOD:
```go
for i := range list.Items {
    obj := &list.Items[i]
}
```

BAD:
```go
for _, obj := range list.Items {
}
```

### Local slices after Create/Patch (MUST)

If a Reconcile method creates objects and keeps a local slice/list for subsequent logic,
it **MUST** append/insert the created objects in their final in-memory state
(including updated `resourceVersion`, defaults, and generated fields).

---

## Reconciliation patterns (MUST)

### Pattern selection rule (MUST)

- Each Reconcile method **MUST** choose exactly one pattern.
- The choice **MUST** be documented in GoDoc.

### Pattern 1: In-place reconciliation

Ensure/Mutate → Detect → Patch

Use when reconciliation is naturally step-by-step and imperative.

### Pattern 2: Desired-state driven

computeDesired → isUpToDate → apply → patch

Use when desired state is compact and comparison is trivial.

### Pattern 3 (default): Conditional desired evaluation

computeDesiredIfNeeded → apply → patch

Default declarative style; avoids `DeepCopy` when no patch is needed.

---

## Mixing patterns (FORBIDDEN) (MUST)

Forbidden within one Reconcile method:

- main uses Pattern 3, status uses Pattern 1;
- main uses Pattern 2, status uses Pattern 3.

Allowed:

- same pattern for all domains;
- split into multiple Reconcile methods, each with its own pattern.

---

## Child resources and decomposition (MUST)

- Child resources **SHOULD** be reconciled in separate Reconcile methods:
  - group reconciler (list + ordering);
  - per-object reconciler.
- Prefer passing already loaded objects.
- Always pass pointers from list iteration.
- Caller owns ordering relative to patching.

---

## Business logic failures & requeue policy (MUST)

- Business-logic blocking conditions **MUST** return an error.
- Exception: if unblocked by watched resources, returning “done / no-op” is acceptable.
- If unblocked by **unwatched** events:
  - return an error, or
  - requeue only with clear justification and visible status signal.

---

## Error wrapping & context (MUST)

- Errors propagated upward **MUST** be wrapped with context.
- Errors **MUST** describe:
  - what action failed,
  - at what orchestration step / responsibility boundary.

### Error identity rules (MUST)

- Do **NOT** include the primary reconcile object identity (`name` / `namespace`)
  or controller identity in the error string:
  - controller-runtime logger already carries:
    `controller`, `controllerGroup`, `controllerKind`,
    `name`, `namespace` (when namespaced), `reconcileID`.
- Duplicating them in error strings is forbidden noise.

### Secondary / child identities (MUST)

- If reconciliation targets **secondary / child resources**,
  you **MUST** include that resource identity in the error
  (`namespace/name` or `name` for cluster-scoped resources).

Rationale:
- controller-runtime logger identity refers only to the **primary** reconcile object.

---

## API helpers vs controller business logic (MUST)

- Mechanical helpers (`Get/Set/Has`) **MUST** live on API types.
- No business decisions in API helpers.
- Business logic stays in Reconcile methods and ReconcileHelpers.

---

## objutilv1 usage (MUST)

All work with:

- labels,
- annotations,
- finalizers,
- owner references,
- conditions

**MUST** go through `objutilv1`, imported as `obju`.

Manual manipulation is forbidden unless `objutilv1` is extended.
