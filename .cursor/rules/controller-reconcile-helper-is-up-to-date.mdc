---
description: Controller reconciliation helpers — IsUpToDateReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# IsUpToDateReconcileHelper

This document defines naming and contracts for **IsUpToDateReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **IsUpToDateReconcileHelpers** (`is*UpToDate`) are tiny, **pure**, **deterministic**, strictly **non-I/O** boolean checks.
- They compare the current `obj` state to a single **desired value** for **exactly one** **patch domain** (**main patch domain** or **status patch domain**) and return `true/false`.
- They **SHOULD NOT** return errors, **MUST NOT** do **Outcome control flow**, and **MUST NOT** log.
- They treat `obj` and `desired` as **read-only inputs** (no mutations, including via map/slice **Aliasing**; **Clone** before any normalization).

---

## Definition

An **IsUpToDateReconcileHelper** (“up-to-date helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- checks whether the current object state is **already equal to the desired state** for **exactly one patch domain** (**main resource** or **status subresource**), and
- returns a boolean result.

Typical up-to-date helpers gate patch execution by answering “do we need to patch this domain?” for a single desired input.

---

## Naming

- An **IsUpToDateReconcileHelper** name **MUST** start with `is` / `Is` and **MUST** contain `UpToDate`.
- **IsUpToDateReconcileHelpers** **MUST** be domain-explicit in the name when ambiguity is possible (ambiguity is possible when the checked “thing” name refers to a field/group that exists in both `.spec` (**main patch domain**) and `.status` (**status patch domain**) of the same **object**):
  - `isMain*UpToDate` / `IsMain*UpToDate` / `is*MainUpToDate` / `Is*MainUpToDate`
  - `isStatus*UpToDate` / `IsStatus*UpToDate` / `is*StatusUpToDate` / `Is*StatusUpToDate`
- **IsUpToDateReconcileHelpers** **SHOULD NOT** include `Main` / `Status` in the name when there is no such ambiguity.
- **IsUpToDateReconcileHelpers** names **MUST NOT** include `Desired` / `Actual` unless the checked “thing” name includes `Desired` / `Actual`.
- **IsUpToDateReconcileHelpers** names **SHOULD** name the “thing” being checked for drift:
  - `isLabelsUpToDate(obj, desiredLabels)`
  - `isSpecFooUpToDate(obj, desiredFoo)`
  - `isStatusUpToDate(obj, desiredStatus)` (ok when status is small; otherwise prefer artifact-specific checks)
  - `isConditionsUpToDate(obj, desiredConditions)`
- **IsUpToDateReconcileHelpers** names **SHOULD NOT** be generic (`isUpToDate`, `isEverythingUpToDate`) — the name should communicate the **patch domain** + artifact being compared.

---

## Preferred signatures

- For **IsUpToDateReconcileHelpers** (`is*UpToDate`), the simplest signature from the variants below that preserves explicit dependencies and purity **SHOULD** be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they **MAY** also be used.

### Simple check (no flow, no logging)
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool
```

---

## Receivers

- **IsUpToDateReconcileHelpers** **MUST** be plain functions (no `Reconciler` receiver).

---

## I/O boundaries

**IsUpToDateReconcileHelpers** **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

**IsUpToDateReconcileHelpers** **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: up-to-date helpers should be **deterministic** and unit-testable; all observable side effects belong to **Reconcile methods**.

---

## Determinism contract

An **IsUpToDateReconcileHelper** **MUST** be **deterministic** given its explicit inputs and read-only dependencies.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular, avoid producing “equivalent but different” intermediate representations across runs (e.g., unstable ordering that flips the boolean result depending on traversal).

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract

`is*UpToDate` / `Is*UpToDate` **MUST** treat all inputs as read-only:

- it **MUST NOT** mutate any input values (including `obj`, `desired`, and any other args);
- it **MUST NOT** perform in-place modifications through aliases.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- `is*UpToDate` / `Is*UpToDate` **MUST** check **exactly one** patch domain:
  - **main resource** (**metadata + spec + non-status fields**), **or**
  - **status subresource** (`.status`).
- If you need to check both domains, you **MUST** use **two** separate helpers (one per **patch domain**), and combine the results in **Reconcile methods**.

✅ Main-only / status-only (GOOD)
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFooMain) bool
func isFooStatusUpToDate(obj *v1alpha1.Foo, desired DesiredFooStatus) bool
```

❌ Mixed domains in one helper (BAD)
```go
func isFooUpToDate(
    obj *v1alpha1.Foo,
    desiredMain DesiredFooMain,
    desiredStatus DesiredFooStatus,
) bool
```

---

## Composition

- An **IsUpToDateReconcileHelper** **MUST** stay a single, simple check: it returns exactly one boolean for one desired input.
- If multiple “pieces” must be checked together for the same domain, they **SHOULD** be bundled into a single `desired` value (small struct) and checked in one helper.
- An **IsUpToDateReconcileHelper** **MAY** call other `is*UpToDate` helpers for reuse (pure composition).
  - It **SHOULD NOT** use such calls to compose independent checks; independent checks should be composed in Reconcile methods.
- If checks are meaningfully independent and will be used separately, they **SHOULD** be split into separate `is*UpToDate` helpers and composed in Reconcile methods (not inside the helper).

---

## Flow phases and **Outcome**

- **IsUpToDateReconcileHelpers** **MUST NOT** create a `reconcile/flow` **phase** (they do not accept `ctx context.Context`; see `controller-reconcile-helper.mdc`).
- **IsUpToDateReconcileHelpers** **MUST NOT** return **Outcome** (in code: `flow.Outcome`) (they are pure checks).
  - If you need flow control (requeue, done, fail), keep it in the caller and/or use other helper categories (e.g., compute/ensure/patch).
- **IsUpToDateReconcileHelpers** **MUST NOT** log.

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- **IsUpToDateReconcileHelpers** **SHOULD** be designed to be non-failing (pure checks).
  - If an error is realistically possible, prefer handling it in a **ComputeReconcileHelper** (or in the caller) and pass only validated/normalized inputs to `is*UpToDate`.
- **IsUpToDateReconcileHelpers** **MUST NOT** create/wrap/enrich errors, and **MUST NOT** include **object identity** (e.g. `namespace/name`, UID, object key).
- Do **not** log and also return a “failure signal” for the same condition unless the surrounding reconcile style explicitly requires it (avoid duplicate logs).

---

## Common anti-patterns (**MUST NOT**)

❌ Doing any Kubernetes API I/O (directly or indirectly):
```go
func isFooUpToDate(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // forbidden: I/O in IsUpToDate helper
    var cm corev1.ConfigMap
    _ = r.client.Get(ctx, nn, &cm)
    return true
}
```

❌ Returning `error` as part of the signature when it is avoidable:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) (bool, error) { // avoid
    return true, nil
}
```

❌ Doing flow control / returning `flow.Outcome`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) flow.Outcome { // forbidden
    return flow.Continue()
}
```

❌ Logging or creating phases (no `ctx`, no logs):
```go
func isFooUpToDate(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) bool { // forbidden shape
    l := log.FromContext(ctx)
    l.Info("checking up-to-date") // forbidden: no logging
    return true
}
```

❌ Calling `DeepCopy`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    _ = obj.DeepCopy() // forbidden
    return true
}
```

❌ Mutating `obj` (even “harmless” changes):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    obj.Spec.Replicas = desired.Replicas // forbidden: IsUpToDate is read-only
    return false
}
```

❌ Mutating `desired`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    desired.Replicas = 3 // forbidden: desired is read-only
    return obj.Spec.Replicas == desired.Replicas
}
```

❌ Mutating through aliasing (maps/slices from inputs):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    ids := obj.Spec.IDs
    slices.Sort(ids) // forbidden: sorts in place and mutates obj
    return true
}
```

❌ Depending on map iteration order (nondeterministic boolean):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // obj.Spec.Flags is a map[string]bool
    got := make([]string, 0, len(obj.Spec.Flags))
    for k := range obj.Spec.Flags { // map iteration order is random
        got = append(got, k)
    }
    // comparing to desired.Keys without sorting => nondeterministic result
    return reflect.DeepEqual(got, desired.Keys)
}
```

❌ Checking both patch domains in one helper:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // forbidden: mixes main + status checks
    mainOK := obj.Spec.Replicas == desired.Replicas
    statusOK := obj.Status.Phase == desired.Phase
    return mainOK && statusOK
}
```
