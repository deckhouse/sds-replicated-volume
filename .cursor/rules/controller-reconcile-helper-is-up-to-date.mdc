---
description: Controller reconciliation helpers — IsUpToDateReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# IsUpToDateReconcileHelper

This document defines naming and contracts for **IsUpToDateReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- `is*UpToDate` helpers are **tiny, pure, deterministic, strictly non-I/O** boolean checks.
- They compare the current `obj` state to a **single desired input** for **exactly one patch domain** (**main** or **status**) and return `true/false`.
- They **SHOULD NOT** return errors, **MUST NOT** do **flow control**, and **MUST NOT** log.
- They treat `obj` and `desired` as **read-only** (no mutations, including via map/slice **aliasing**; **clone** before any normalization).

---

## Definition

An **IsUpToDateReconcileHelper** (“up-to-date helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- checks whether the current object state is **already equal to the desired state** for **exactly one patch domain** (**main resource** or **status subresource**), and
- returns a boolean result.

Typical up-to-date helpers gate patch execution by answering “do we need to patch this domain?” for a single desired input.

---

## Naming

- An **IsUpToDateReconcileHelper** name **MUST** start with `is` / `Is` and **MUST** contain `UpToDate`.
- IsUpToDateReconcileHelpers **MUST** be domain-explicit in the name when ambiguity is possible (ambiguity is possible when the checked “thing” name refers to a field/group that exists in both `.spec` and `.status` of the same object):
  - `isMain*UpToDate` / `IsMain*UpToDate` / `is*MainUpToDate` / `Is*MainUpToDate`
  - `isStatus*UpToDate` / `IsStatus*UpToDate` / `is*StatusUpToDate` / `Is*StatusUpToDate`
- IsUpToDateReconcileHelpers **SHOULD NOT** include `Main` / `Status` in the name when there is no such ambiguity.
- IsUpToDateReconcileHelper names **MUST NOT** include `Desired` / `Actual` unless the checked “thing” name includes `Desired` / `Actual`.
- IsUpToDateReconcileHelper names **SHOULD** name the “thing” being checked for drift:
  - `isLabelsUpToDate(obj, desiredLabels)`
  - `isSpecFooUpToDate(obj, desiredFoo)`
  - `isStatusUpToDate(obj, desiredStatus)` (ok when status is small; otherwise prefer artifact-specific checks)
  - `isConditionsUpToDate(obj, desiredConditions)`
- IsUpToDateReconcileHelper names **SHOULD NOT** be generic (`isUpToDate`, `isEverythingUpToDate`) — the name should communicate the domain + artifact being compared.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and purity.

### Simple check (no flow, no logging) (SHOULD)
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool
```

---

## Receivers (MUST)

- IsUpToDateReconcileHelpers **MUST** be plain functions (no `Reconciler` receiver).

---

## I/O boundaries (MUST)

IsUpToDateReconcileHelpers **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

IsUpToDateReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: up-to-date helpers should be deterministic and unit-testable; all observable side effects belong to Reconcile methods.

---

## Determinism contract (MUST)

An IsUpToDateReconcileHelper **MUST** be deterministic given its explicit inputs and read-only dependencies.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular, avoid producing “equivalent but different” intermediate representations across runs (e.g., unstable ordering that flips the boolean result depending on traversal).

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract (MUST)

`is*UpToDate` / `Is*UpToDate` **MUST** treat all inputs as read-only:

- it **MUST NOT** mutate any input values (including `obj`, `desired`, and any other args);
- it **MUST NOT** perform in-place modifications through aliases.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation (MUST)

- `is*UpToDate` / `Is*UpToDate` **MUST** check **exactly one** patch domain:
  - main resource (**metadata + spec + non-status fields**), **or**
  - status subresource (`.status`).
- If you need to check both domains, you **MUST** use **two** separate helpers (one per domain), and combine the results in Reconcile methods.

✅ Main-only / status-only (GOOD)
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFooMain) bool
func isFooStatusUpToDate(obj *v1alpha1.Foo, desired DesiredFooStatus) bool
```

❌ Mixed domains in one helper (BAD)
```go
func isFooUpToDate(
    obj *v1alpha1.Foo,
    desiredMain DesiredFooMain,
    desiredStatus DesiredFooStatus,
) bool
```

---

## Composition (MUST)

- An IsUpToDateReconcileHelper **MUST** stay a single, simple check: it returns exactly one boolean for one desired input.
- If multiple “pieces” must be checked together for the same domain, they **SHOULD** be bundled into a single `desired` value (small struct) and checked in one helper.
- An IsUpToDateReconcileHelper **MAY** call other `is*UpToDate` helpers for reuse (pure composition).
  - It **SHOULD NOT** use such calls to compose independent checks; independent checks should be composed in Reconcile methods.
- If checks are meaningfully independent and will be used separately, they **SHOULD** be split into separate `is*UpToDate` helpers and composed in Reconcile methods (not inside the helper).

---

## Flow phases and **Outcome**

- **IsUpToDateReconcileHelpers** **MUST NOT** create a `reconcile/flow` **phase** (they do not accept `ctx context.Context`; see `controller-reconcile-helper.mdc`).
- **IsUpToDateReconcileHelpers** **MUST NOT** return **Outcome** (in code: `flow.Outcome`) (they are pure checks).
  - If you need flow control (requeue, done, fail), keep it in the caller and/or use other helper categories (e.g., compute/ensure/patch).
- **IsUpToDateReconcileHelpers** **MUST NOT** log.

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- **IsUpToDateReconcileHelpers** **SHOULD** be designed to be non-failing (pure checks).
  - If an error is realistically possible, prefer handling it in a **ComputeReconcileHelper** (or in the caller) and pass only validated/normalized inputs to `is*UpToDate`.
- **IsUpToDateReconcileHelpers** **MUST NOT** create/wrap/enrich errors, and **MUST NOT** include **object identity** (e.g. `namespace/name`, UID, object key).
- Do **not** log and also return a “failure signal” for the same condition unless the surrounding reconcile style explicitly requires it (avoid duplicate logs).

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API I/O (directly or indirectly):
```go
func isFooUpToDate(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // forbidden: I/O in IsUpToDate helper
    var cm corev1.ConfigMap
    _ = r.client.Get(ctx, nn, &cm)
    return true
}
```

❌ Returning `error` as part of the signature when it is avoidable:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) (bool, error) { // avoid
    return true, nil
}
```

❌ Doing flow control / returning `flow.Outcome`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) flow.Outcome { // forbidden
    return flow.Continue()
}
```

❌ Logging or creating phases (no `ctx`, no logs):
```go
func isFooUpToDate(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) bool { // forbidden shape
    l := log.FromContext(ctx)
    l.Info("checking up-to-date") // forbidden: no logging
    return true
}
```

❌ Calling `DeepCopy`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    _ = obj.DeepCopy() // forbidden
    return true
}
```

❌ Mutating `obj` (even “harmless” changes):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    obj.Spec.Replicas = desired.Replicas // forbidden: IsUpToDate is read-only
    return false
}
```

❌ Mutating `desired`:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    desired.Replicas = 3 // forbidden: desired is read-only
    return obj.Spec.Replicas == desired.Replicas
}
```

❌ Mutating through aliasing (maps/slices from inputs):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    ids := obj.Spec.IDs
    slices.Sort(ids) // forbidden: sorts in place and mutates obj
    return true
}
```

❌ Depending on map iteration order (nondeterministic boolean):
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // obj.Spec.Flags is a map[string]bool
    got := make([]string, 0, len(obj.Spec.Flags))
    for k := range obj.Spec.Flags { // map iteration order is random
        got = append(got, k)
    }
    // comparing to desired.Keys without sorting => nondeterministic result
    return reflect.DeepEqual(got, desired.Keys)
}
```

❌ Checking both patch domains in one helper:
```go
func isFooUpToDate(obj *v1alpha1.Foo, desired DesiredFoo) bool {
    // forbidden: mixes main + status checks
    mainOK := obj.Spec.Replicas == desired.Replicas
    statusOK := obj.Status.Phase == desired.Phase
    return mainOK && statusOK
}
```
