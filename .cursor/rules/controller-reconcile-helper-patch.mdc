---
description: Controller reconciliation helpers — PatchReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# PatchReconcileHelper

This document defines naming and contracts for **PatchReconcileHelper** functions/methods.

Common terminology and rules for any ReconcileHelper live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

- `patch<Kind>` helpers are **single-call I/O helpers**: they execute exactly **one** patch request for exactly **one** patch domain (`Patch(...)` main **or** `Status().Patch(...)` status).
- They take `base` explicitly (created by Reconcile methods immediately before the patch) and an explicit `optimisticLock` flag, and **MUST NOT** decide patch ordering or patch strategy beyond that flag.
- They **MUST** patch using the **caller-owned object instance** (`obj`) and, on success, the **same instance MUST be updated** with API-server-updated fields (e.g., `resourceVersion`, managed fields, defaults).
- They **MUST NOT** do any other API calls (`Get/List/Create/Update/Delete`), **MUST NOT** call `DeepCopy`, and **MUST NOT** patch both domains in one helper.
- They **MUST** treat `base` as **read-only** and stay deterministic in everything they control (no hidden I/O: no time/random/env/network beyond the single patch request).

---

## ALLOW / DENY cheat sheet

**ALLOW (MAY):**
- Execute **exactly one** Kubernetes patch request for **exactly one** patch domain:
  - main: `r.client.Patch(ctx, obj, ...)`, or
  - status: `r.client.Status().Patch(ctx, obj, ...)`.
- Use the **caller-provided** `base` as the diff reference (e.g. `client.MergeFrom(base)` or the codebase’s standard patch constructor).
- Respect the **caller-provided** `optimisticLock` flag by selecting the corresponding patch option/mode **without changing the decision**.
- Return `flow.Outcome` (or `error`, if the category intentionally uses errors) that reflects only:
  - success/failure of the single patch call,
  - and any retry/requeue decision that is purely mechanical for this call (if your codebase does that inside patch helpers).
- Observe that **the API server mutates `obj`** as a result of the patch call (e.g., `resourceVersion`, managed fields, defaults), i.e. it’s expected that **`obj` is updated in-place by the client call**.
- Treat `base` and all other non-`obj` inputs as **read-only** (including maps/slices inside `base`).

**DENY (MUST NOT):**
- Any Kubernetes API calls other than the single patch call:
  - no `Get`, no `List`, no `Create`, no `Update`, no `Delete`,
  - no second patch call,
  - no status patch plus main patch in the same helper.
- Patching **both** patch domains in one helper (must be exactly one domain per helper).
- Calling `DeepCopy` (`obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.) — the caller creates `base`.
- Mutating `base` (directly or through aliasing of maps/slices); `base` is **read-only diff reference**.
- Performing **business-logic** mutations on `obj` inside the patch helper:
  - no “ensure/apply” logic,
  - no setting fields “just before patch”,
  - no normalization that changes intent.
- Making patch ordering / orchestration decisions:
  - no “patch main then status”,
  - no “if X then patch status first”,
  - no “retry loops that perform extra API calls”.
- Overriding or re-deciding the optimistic-locking choice:
  - must not flip `optimisticLock`,
  - must not infer/decide it from object state inside the helper.
- Hidden I/O / nondeterminism beyond the single patch request:
  - no `time.Now()` / `time.Since(...)`,
  - no `rand.*` / UUID generation,
  - no `os.Getenv` / filesystem reads,
  - no network calls other than the single Kubernetes API patch request.
- Patching multiple objects in one helper (loops/fan-out belong to Reconcile methods).

---

## Definition (MUST)

A **PatchReconcileHelper** (“patch helper”) is a **ReconcileHelper** that is:

- **allowed to perform I/O**, and
- executes exactly **one** Kubernetes patch request for exactly **one patch domain** (main resource patch **or** status subresource patch), and
- returns the patch outcome (and optionally an error).

Typical patch helpers encapsulate the mechanical “patch this domain now” operation (including optimistic-lock semantics) and ensure the caller-visible in-memory object reflects server-assigned fields after the patch (e.g., `resourceVersion`, defaults), while Reconcile methods still own patch ordering decisions across multiple patches.

---

## Naming (MUST)

- A **PatchReconcileHelper** name **MUST** start with `patch` / `Patch`.
- PatchReconcileHelpers **MUST** use the form:
  - `patch<Kind>` / `Patch<Kind>`.

Guidance (SHOULD):
- `<Kind>` MUST correspond to the Kubernetes object kind being patched.
- A short kind name is allowed, if it is already established in the codebase.
- Examples:
  - `patchCM(...)` (or `patchConfigMap(...)`)
  - `patchSVC(...)` (or `patchService(...)`)
  - `patchSKN(...)` (or `patchSomeKindName(...)`)
- Avoid names that hide strategy or ordering (`patchOptimistically`, `patchAll`, `patchWithOrdering`) — patch helpers execute exactly one patch; ordering and strategy decisions live in Reconcile methods.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and a single-patch scope.

### Simple patch (SHOULD)
Pass `base` explicitly (created in the Reconcile methods immediately before the patch)
and an explicit optimistic-lock flag:
```go
func (r *Reconciler) patchSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) flow.Outcome
```

Or, if `flow.Outcome` is intentionally not used:
```go
func (r *Reconciler) patchSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) error
```

### Status-subresource patch variant (SHOULD)
```go
func (r *Reconciler) patchSKNStatus(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) flow.Outcome
```

Or, if `flow.Outcome` is intentionally not used:
```go
func (r *Reconciler) patchSKNStatus(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) error
```

---

## Receivers (MUST)

- PatchReconcileHelpers **MUST** be methods on `Reconciler` (they perform I/O via controller-runtime client owned by `Reconciler`).

---

## I/O boundaries (MUST)

PatchReconcileHelpers **MAY** do the following:

- controller-runtime client usage to execute exactly **one** Kubernetes patch call for exactly **one** patch domain:
  - `Patch(...)` (main resource), or
  - `Status().Patch(...)` (status subresource),
  using the optimistic-locking mode provided by the caller (e.g., derived from `flow.Outcome`).

PatchReconcileHelpers **MUST NOT** do any of the following:

- Kubernetes API calls other than that single patch call (no `Get/List/Create/Update/Delete`, no second patch);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- making any patch ordering decisions across multiple patch requests;
- performing any other I/O besides the single Kubernetes API request they own.

PatchReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind **other than** the single Kubernetes API request they own.

> Rationale: patch helpers are mechanical “execute exactly one patch” operations; ordering and multi-step reconciliation policy remain explicit and reviewable in Reconcile methods.

---

## Determinism contract (MUST)

A PatchReconcileHelper **MUST** be deterministic in everything it controls.

In particular:
- It **MUST** execute a single patch request whose parameters are determined only by explicit inputs (`obj`, `base`, `optimisticLock`, domain).
- See the common determinism contract in `controller-reconcile-helper.mdc` (ordering stability, no map iteration order reliance).
- It **MUST NOT** introduce “hidden I/O” (time, random, env, extra network calls) beyond the single patch request they own.

> Practical reason: nondeterminism produces patch churn and makes conflicts hard to reason about.

---

## Read-only contract (MUST)

`patch<Kind>` / `Patch<Kind>` **MUST** treat inputs as read-only.

In particular, it **MUST** treat `base` as read-only (it is the patch base / diff reference):

- it **MUST NOT** mutate `base` (it is the patch base / diff reference);
- it **MUST NOT** mutate any other inputs;
- it MAY observe `obj` being updated as a result of the patch call (e.g., `resourceVersion`, defaults), but **MUST NOT** perform additional in-memory business mutations inside the patch helper.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation (MUST)

- A PatchReconcileHelper **MUST** execute exactly **one** patch request for exactly **one** patch domain:
  - main resource patch domain: `Patch(...)`, **or**
  - status subresource patch domain: `Status().Patch(...)`.
- A PatchReconcileHelper **MUST NOT** patch both domains in one helper.
- If both domains need patching, Reconcile methods **MUST** issue two separate patch operations (typically via two patch helpers), each with its own `base` and request.

## Composition (MUST)

- A PatchReconcileHelper **MUST** execute exactly one patch request for exactly one patch domain.
- A PatchReconcileHelper **MAY** be preceded by pure helpers that prepared the in-memory `obj` (compute/apply/ensure), but the patch helper itself **MUST NOT** perform any business-logic composition beyond executing the single patch request.
- If multiple patch requests are needed (multiple domains or multiple sequential patches), they **MUST** be composed in Reconcile methods as multiple explicit patch operations (each with its own `base` taken immediately before that patch).

## Flow phases and `flow.Outcome` (MUST)

- PatchReconcileHelpers **MUST NOT** create a `reconcile/flow` phase — they should stay mechanical and short.
- If a PatchReconcileHelper returns `flow.Outcome`, it **SHOULD** use helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.
  - Prefer encoding retry/requeue policy explicitly in the returned outcome.

---

## Error handling (SHOULD)

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- A PatchReconcileHelper SHOULD be mechanically thin: if the single patch call fails, return the error **without wrapping**.
  - If returning `flow.Outcome`, use `flow.Fail(err)` (or equivalent) with the original `err`.
- A PatchReconcileHelper MUST NOT enrich errors with additional context (including reconcile object identity such as `namespace/name`, UID, object key).
  - Error enrichment (action + object identity + phase) is the calling Reconcile method’s responsibility.

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API calls other than the single patch request (`Get/List/Create/Update/Delete`, or a second patch):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: extra API call
    var cur v1alpha1.EON
    if err := r.client.Get(ctx, client.ObjectKeyFromObject(obj), &cur); err != nil {
        return err
    }

    // forbidden: patch after an extra call (still >1 API call in helper)
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Calling `DeepCopy` inside patch helpers (the caller creates `base`):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Patching a temporary copy and dropping it (caller-owned `obj` stays stale):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    tmp := obj.DeepCopy() // also forbidden: DeepCopy in patch helper
    if err := r.client.Patch(ctx, tmp, client.MergeFrom(base)); err != nil {
        return err
    }
    // forbidden: obj is not updated with new resourceVersion/defaults
    return nil
}
```

❌ Patching both patch domains in one helper:
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: two requests / two domains
    if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // main
        return err
    }
    return r.client.Status().Patch(ctx, obj, client.MergeFrom(base)) // status
}
```

❌ Making patch ordering decisions (patch helpers execute exactly one patch, ordering lives in Reconcile methods):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: deciding to patch status first / mixing ordering policy into the helper
    if needsStatus(obj) {
        if err := r.client.Status().Patch(ctx, obj, client.MergeFrom(base)); err != nil {
            return err
        }
    }
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Overriding the caller’s optimistic-locking decision:
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    optimisticLock = true // forbidden: helper must not change the decision
    // ...
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Performing business-logic mutations inside the patch helper (beyond the patch call itself):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: business mutations belong to compute/apply/ensure before calling patch
    obj.Spec.Replicas = 3
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Mutating `base` (it is read-only diff reference):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    labels := base.GetLabels()
    labels["x"] = "y" // forbidden: mutates base via alias
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Hidden I/O / nondeterminism (time/random/env/extra network calls):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    if os.Getenv("PATCH_FAST") == "1" { // forbidden: env read in helper
        // ...
    }
    _ = time.Now() // forbidden
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Using broad patch helpers that patch multiple objects (must patch exactly one object instance):
```go
func (r *Reconciler) patchEONs(ctx context.Context, objs []*v1alpha1.EON, base *v1alpha1.EON, optimisticLock bool) error {
    for _, obj := range objs {
        if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // forbidden: multiple API calls
            return err
        }
    }
    return nil
}
```
