---
description: Contracts for PatchReconcileHelper (patch<Kind>) functions: exactly one patch request for one patch domain (main or status), explicit base + optimistic-lock flag, and no other I/O. Apply when writing patch* helpers in reconciler*.go, and when deciding patch mechanics for main vs status. Apply when editing relevant files, and when reasoning/planning/answering questions where this rule could influence code decisions (even if matching files are not currently open).
globs: images/controller/internal/controllers/rv_controller/reconciler*.go,images/controller/internal/controllers/rv_attach_controller/reconciler*.go
alwaysApply: false
---

See `rfc-like-mdc.mdc` for normative keywords (BCP 14 / RFC 2119 / RFC 8174) and general .mdc writing conventions.

# PatchReconcileHelper

This document defines naming and contracts for **PatchReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **PatchReconcileHelpers** (`patch<Kind>`) are **single-call I/O helpers**: they execute exactly one **patch request** for exactly one **patch domain** (`Patch(...)` (**main patch domain**) or `Status().Patch(...)` (**status patch domain**)).
- They take `base` explicitly (created by **Reconcile methods** immediately before the patch) and an explicit `optimisticLock` flag, and MUST NOT decide **patch ordering** or **patch strategy** beyond that flag.
- They MUST patch using the **caller-owned object instance** (`obj`) and, on success, the same instance MUST be updated with **API-server-updated fields** (e.g., `resourceVersion`, managed fields, defaults).
- They MUST NOT perform any other **Kubernetes API I/O** calls (`Get/List/Create/Update/Delete`), MUST NOT call **DeepCopy**, and MUST NOT patch both **patch domains** in one helper.
- They MUST treat `base` as **read-only inputs** and stay **deterministic** in everything they control (no **Hidden I/O**: no time/random/env/network beyond the single **patch request**).

Notes:
- A status-domain patch (`Status().Patch(...)`) persists Kubernetes POV **observed state** (`.status`), which may include both:
  - **controller-owned state** (persisted decisions/memory), and
  - the published **report** (conditions/progress/selected observations).
  Patch helpers stay agnostic; deciding *what* should be in `.status` (and keeping roles distinct) belongs to **Reconcile methods** + compute/apply helpers.

---

## Definition

A **PatchReconcileHelper** (“patch helper”) is a **ReconcileHelper** that is:

- **allowed to perform I/O**, and
- executes exactly **one** **Kubernetes patch request** for exactly **one patch domain** (**main resource patch** or **status subresource patch**), and
- returns the patch outcome (and optionally an error).

Typical patch helpers encapsulate the mechanical “patch this domain now” operation (including optimistic-lock semantics) and ensure the caller-visible in-memory object reflects server-assigned fields after the patch (e.g., `resourceVersion`, defaults), while **Reconcile methods** still own **patch ordering** decisions across multiple patches.

---

## Naming

- A **PatchReconcileHelper** name MUST start with `patch` / `Patch`.
- **PatchReconcileHelpers** MUST use the form:
  - `patch<Kind>` / `Patch<Kind>` (**main patch domain**)
  - `patch<Kind>Status` / `Patch<Kind>Status` (**status patch domain**)
  `<Kind>` MUST either correspond to the Kubernetes **object** kind being patched or be a short kind name that is already established in the codebase.
  When `<Kind>` refers to a kind defined in this repository’s API (types under `api/v*/`), `<Kind>` MUST use the **short kind name** (see `controller-terminology.mdc`).
  Examples:
  - `patchCM(...)` (or `patchConfigMap(...)`)
  - `patchCMStatus(...)` (or `patchConfigMapStatus(...)`)
  - `patchSVC(...)` (or `patchService(...)`)
  - `patchSVCStatus(...)` (or `patchServiceStatus(...)`)
  - `patchEK(...)` (or `patchExampleKind(...)`)
  - `patchEKStatus(...)` (or `patchExampleKindStatus(...)`)
- **PatchReconcileHelpers** names MUST NOT hide strategy or ordering (`patchOptimistically`, `patchAll`, `patchWithOrdering`) — patch helpers execute exactly one patch; ordering and strategy decisions live in **Reconcile methods**.

---

## Preferred signatures

- For **PatchReconcileHelpers** (`patch*`), the simplest signature from the variants below that preserves explicit dependencies and a single-patch scope SHOULD be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they MAY also be used.

### Simple patch
Pass `base` explicitly (created in the **Reconcile methods** immediately before the patch)
and an explicit optimistic-lock flag:
```go
func (r *Reconciler) patchEK(
    ctx context.Context,
    obj *v1alpha1.ExampleKind,
    base *v1alpha1.ExampleKind,
    optimisticLock bool,
) error
```

### Status-subresource patch variant
```go
func (r *Reconciler) patchEKStatus(
    ctx context.Context,
    obj *v1alpha1.ExampleKind,
    base *v1alpha1.ExampleKind,
    optimisticLock bool,
) error
```

### Implementation example (illustrative)

```go
func (r *Reconciler) patchEK(
    ctx context.Context,
    obj *v1alpha1.ExampleKind,
    base *v1alpha1.ExampleKind,
    optimisticLock bool,
) error {
    var patch client.Patch
    if optimisticLock {
        patch = client.MergeFromWithOptions(base, client.MergeFromWithOptimisticLock{})
    } else {
        patch = client.MergeFrom(base)
    }
    return r.client.Patch(ctx, obj, patch)
}

func (r *Reconciler) patchEKStatus(
    ctx context.Context,
    obj *v1alpha1.ExampleKind,
    base *v1alpha1.ExampleKind,
    optimisticLock bool,
) error {
    var patch client.Patch
    if optimisticLock {
        patch = client.MergeFromWithOptions(base, client.MergeFromWithOptimisticLock{})
    } else {
        patch = client.MergeFrom(base)
    }
    return r.client.Status().Patch(ctx, obj, patch)
}
```

---

## Receivers

- **PatchReconcileHelpers** MUST be methods on `Reconciler` (they perform I/O via controller-runtime client owned by `Reconciler`).

---

## I/O boundaries

**PatchReconcileHelpers** MAY do the following:

- controller-runtime client usage to execute exactly **one** Kubernetes patch call for exactly **one** patch domain:
  - `Patch(...)` (main resource), or
  - `Status().Patch(...)` (status subresource),
  using the **Optimistic locking** mode provided by the caller (typically derived from `EnsureOutcome.OptimisticLockRequired()`).

**PatchReconcileHelpers** MUST NOT do any of the following:

- Kubernetes API calls other than that single patch call (no `Get/List/Create/Update/Delete`, no second patch);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- making any patch ordering decisions across multiple patch requests;
- performing any other I/O besides the single Kubernetes API request they own.

**PatchReconcileHelpers** MUST NOT do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind **other than** the single Kubernetes API request they own.

> Rationale: patch helpers are mechanical “execute exactly one patch” operations; ordering and multi-step reconciliation policy remain explicit and reviewable in **Reconcile methods**.

---

## Determinism contract

A **PatchReconcileHelper** MUST be **deterministic** in everything it controls.

In particular:
- It MUST execute a single patch request whose parameters are determined only by explicit inputs (`obj`, `base`, `optimisticLock`, domain).
- See the common determinism contract in `controller-reconcile-helper.mdc` (ordering stability, no map iteration order reliance).
- It MUST NOT introduce “hidden I/O” (time, random, env, extra network calls) beyond the single patch request they own.

> Practical reason: nondeterminism produces patch churn and makes conflicts hard to reason about.

---

## Read-only contract

`patch<Kind>` / `Patch<Kind>` MUST treat inputs as read-only.

In particular, it MUST treat `base` as read-only (it is the patch base / diff reference):

- it MUST NOT mutate `base` (it is the patch base / diff reference);
- it MUST NOT mutate any other inputs;
- it MAY observe `obj` being updated as a result of the patch call (e.g., `resourceVersion`, defaults), but MUST NOT perform additional in-memory business mutations inside the patch helper.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- A **PatchReconcileHelper** MUST execute exactly **one** patch request for exactly **one** patch domain:
  - **main resource** patch domain: `Patch(...)`, **or**
  - **status subresource** patch domain: `Status().Patch(...)`.
- A **PatchReconcileHelper** MUST NOT patch both domains in one helper.
- If both domains need patching, **Reconcile methods** MUST issue two separate patch operations (typically via two patch helpers), each with its own `base` and request.

---

## Composition

- A **PatchReconcileHelper** MUST execute exactly one patch request for exactly one patch domain.
- A **PatchReconcileHelper** MAY be preceded by pure helpers that prepared the in-memory `obj` (compute/apply/ensure), but the patch helper itself MUST NOT perform any business-logic composition beyond executing the single patch request.
- If multiple patch requests are needed (multiple domains or multiple sequential patches), they MUST be composed in **Reconcile methods** as multiple explicit patch operations (each with its own `base` taken immediately before that patch).
- A **PatchReconcileHelper** MUST NOT call other **ReconcileHelpers**.

---

## Flow phase scopes and outcomes

- **PatchReconcileHelpers** MUST NOT create a `reconcile/flow` **phase scope** — they should stay mechanical and short.
- **PatchReconcileHelpers** MUST return `error` and MUST NOT return **ReconcileOutcome** (`flow.ReconcileOutcome`) or **EnsureOutcome** (`flow.EnsureOutcome`).
  - Any retry/requeue policy belongs to the calling **Reconcile method** (use `ReconcileFlow` there).

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- A **PatchReconcileHelper** SHOULD be mechanically thin: if the single patch call fails, return the error **without wrapping**.
- A **PatchReconcileHelper** MUST NOT enrich errors with additional context (including **object identity** such as `namespace/name`, UID, object key).
  - Error enrichment (action + **object identity** + **phase**) is the calling **Reconcile method**’s responsibility.

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API calls other than the single patch request (`Get/List/Create/Update/Delete`, or a second patch):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    // forbidden: extra API call
    var cur v1alpha1.EK
    if err := r.client.Get(ctx, client.ObjectKeyFromObject(obj), &cur); err != nil {
        return err
    }

    // forbidden: patch after an extra call (still >1 API call in helper)
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Calling `DeepCopy` inside patch helpers (the caller creates `base`):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Patching a temporary copy and dropping it (caller-owned `obj` stays stale):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    tmp := obj.DeepCopy() // also forbidden: DeepCopy in patch helper
    if err := r.client.Patch(ctx, tmp, client.MergeFrom(base)); err != nil {
        return err
    }
    // forbidden: obj is not updated with new resourceVersion/defaults
    return nil
}
```

❌ Patching both patch domains in one helper:
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    // forbidden: two requests / two domains
    if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // main
        return err
    }
    return r.client.Status().Patch(ctx, obj, client.MergeFrom(base)) // status
}
```

❌ Making patch ordering decisions (patch helpers execute exactly one patch, ordering lives in Reconcile methods):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    // forbidden: deciding to patch status first / mixing ordering policy into the helper
    if needsStatus(obj) {
        if err := r.client.Status().Patch(ctx, obj, client.MergeFrom(base)); err != nil {
            return err
        }
    }
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Overriding the caller’s optimistic-locking decision:
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    optimisticLock = true // forbidden: helper must not change the decision
    // ...
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Performing business-logic mutations inside the patch helper (beyond the patch call itself):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    // forbidden: business mutations belong to compute/apply/ensure before calling patch
    obj.Spec.Replicas = 3
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Mutating `base` (it is read-only diff reference):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    labels := base.GetLabels()
    labels["x"] = "y" // forbidden: mutates base via alias
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Hidden I/O / nondeterminism (time/random/env/extra network calls):
```go
func (r *Reconciler) patchEK(ctx context.Context, obj, base *v1alpha1.EK, optimisticLock bool) error {
    if os.Getenv("PATCH_FAST") == "1" { // forbidden: env read in helper
        // ...
    }
    _ = time.Now() // forbidden
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Using broad patch helpers that patch multiple objects (must patch exactly one object instance):
```go
func (r *Reconciler) patchEKs(ctx context.Context, objs []*v1alpha1.EK, base *v1alpha1.EK, optimisticLock bool) error {
    for _, obj := range objs {
        if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // forbidden: multiple API calls
            return err
        }
    }
    return nil
}
```
