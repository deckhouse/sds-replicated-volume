---
description: Controller reconciliation helpers — PatchReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# PatchReconcileHelper

This document defines naming and contracts for **PatchReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **PatchReconcileHelpers** (`patch<Kind>`) are **single-call I/O helpers**: they execute exactly one **patch request** for exactly one **patch domain** (`Patch(...)` (**main patch domain**) or `Status().Patch(...)` (**status patch domain**)).
- They take `base` explicitly (created by **Reconcile methods** immediately before the patch) and an explicit `optimisticLock` flag, and **MUST NOT** decide **patch ordering** or **patch strategy** beyond that flag.
- They **MUST** patch using the **caller-owned object instance** (`obj`) and, on success, the same instance **MUST** be updated with **API-server-updated fields** (e.g., `resourceVersion`, managed fields, defaults).
- They **MUST NOT** perform any other **Kubernetes API I/O** calls (`Get/List/Create/Update/Delete`), **MUST NOT** call **DeepCopy**, and **MUST NOT** patch both **patch domains** in one helper.
- They **MUST** treat `base` as **read-only inputs** and stay **deterministic** in everything they control (no **Hidden I/O**: no time/random/env/network beyond the single **patch request**).

Notes:
- A status-domain patch (`Status().Patch(...)`) persists Kubernetes POV **observed state** (`.status`), which may include both:
  - **controller-owned state** (persisted decisions/memory), and
  - the published **report** (conditions/progress/selected observations).
  Patch helpers stay agnostic; deciding *what* should be in `.status` (and keeping roles distinct) belongs to **Reconcile methods** + compute/apply helpers.

---

## Definition

A **PatchReconcileHelper** (“patch helper”) is a **ReconcileHelper** that is:

- **allowed to perform I/O**, and
- executes exactly **one** **Kubernetes patch request** for exactly **one patch domain** (**main resource patch** or **status subresource patch**), and
- returns the patch outcome (and optionally an error).

Typical patch helpers encapsulate the mechanical “patch this domain now” operation (including optimistic-lock semantics) and ensure the caller-visible in-memory object reflects server-assigned fields after the patch (e.g., `resourceVersion`, defaults), while **Reconcile methods** still own **patch ordering** decisions across multiple patches.

---

## Naming

- A **PatchReconcileHelper** name **MUST** start with `patch` / `Patch`.
- **PatchReconcileHelpers** **MUST** use the form:
  - `patch<Kind>` / `Patch<Kind>` (**main patch domain**)
  - `patch<Kind>Status` / `Patch<Kind>Status` (**status patch domain**)
  `<Kind>` **MUST** either correspond to the Kubernetes **object** kind being patched or be a short kind name that is already established in the codebase. Examples:
  - `patchCM(...)` (or `patchConfigMap(...)`)
  - `patchCMStatus(...)` (or `patchConfigMapStatus(...)`)
  - `patchSVC(...)` (or `patchService(...)`)
  - `patchSVCStatus(...)` (or `patchServiceStatus(...)`)
  - `patchSKN(...)` (or `patchSomeKindName(...)`)
  - `patchSKNStatus(...)` (or `patchSomeKindNameStatus(...)`)
- **PatchReconcileHelpers** names **MUST NOT** hide strategy or ordering (`patchOptimistically`, `patchAll`, `patchWithOrdering`) — patch helpers execute exactly one patch; ordering and strategy decisions live in **Reconcile methods**.

---

## Preferred signatures

- For **PatchReconcileHelpers** (`patch*`), the simplest signature from the variants below that preserves explicit dependencies and a single-patch scope **SHOULD** be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they **MAY** also be used.

### Simple patch
Pass `base` explicitly (created in the **Reconcile methods** immediately before the patch)
and an explicit optimistic-lock flag:
```go
func (r *Reconciler) patchSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) flow.Outcome
```

Or, if **Outcome** (in code, the type is `flow.Outcome`) is intentionally not used:
```go
func (r *Reconciler) patchSKN(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) error
```

### Status-subresource patch variant
```go
func (r *Reconciler) patchSKNStatus(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) flow.Outcome
```

Or, if **Outcome** (in code, the type is `flow.Outcome`) is intentionally not used:
```go
func (r *Reconciler) patchSKNStatus(
    ctx context.Context,
    obj *v1alpha1.SomeKindName,
    base *v1alpha1.SomeKindName,
    optimisticLock bool,
) error
```

---

## Receivers

- **PatchReconcileHelpers** **MUST** be methods on `Reconciler` (they perform I/O via controller-runtime client owned by `Reconciler`).

---

## I/O boundaries

**PatchReconcileHelpers** **MAY** do the following:

- controller-runtime client usage to execute exactly **one** Kubernetes patch call for exactly **one** patch domain:
  - `Patch(...)` (main resource), or
  - `Status().Patch(...)` (status subresource),
  using the **Optimistic locking** mode provided by the caller (e.g., derived from `flow.Outcome`).

**PatchReconcileHelpers** **MUST NOT** do any of the following:

- Kubernetes API calls other than that single patch call (no `Get/List/Create/Update/Delete`, no second patch);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- making any patch ordering decisions across multiple patch requests;
- performing any other I/O besides the single Kubernetes API request they own.

**PatchReconcileHelpers** **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind **other than** the single Kubernetes API request they own.

> Rationale: patch helpers are mechanical “execute exactly one patch” operations; ordering and multi-step reconciliation policy remain explicit and reviewable in **Reconcile methods**.

---

## Determinism contract

A **PatchReconcileHelper** **MUST** be **deterministic** in everything it controls.

In particular:
- It **MUST** execute a single patch request whose parameters are determined only by explicit inputs (`obj`, `base`, `optimisticLock`, domain).
- See the common determinism contract in `controller-reconcile-helper.mdc` (ordering stability, no map iteration order reliance).
- It **MUST NOT** introduce “hidden I/O” (time, random, env, extra network calls) beyond the single patch request they own.

> Practical reason: nondeterminism produces patch churn and makes conflicts hard to reason about.

---

## Read-only contract

`patch<Kind>` / `Patch<Kind>` **MUST** treat inputs as read-only.

In particular, it **MUST** treat `base` as read-only (it is the patch base / diff reference):

- it **MUST NOT** mutate `base` (it is the patch base / diff reference);
- it **MUST NOT** mutate any other inputs;
- it MAY observe `obj` being updated as a result of the patch call (e.g., `resourceVersion`, defaults), but **MUST NOT** perform additional in-memory business mutations inside the patch helper.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- A **PatchReconcileHelper** **MUST** execute exactly **one** patch request for exactly **one** patch domain:
  - **main resource** patch domain: `Patch(...)`, **or**
  - **status subresource** patch domain: `Status().Patch(...)`.
- A **PatchReconcileHelper** **MUST NOT** patch both domains in one helper.
- If both domains need patching, **Reconcile methods** **MUST** issue two separate patch operations (typically via two patch helpers), each with its own `base` and request.

---

## Composition

- A **PatchReconcileHelper** **MUST** execute exactly one patch request for exactly one patch domain.
- A **PatchReconcileHelper** **MAY** be preceded by pure helpers that prepared the in-memory `obj` (compute/apply/ensure), but the patch helper itself **MUST NOT** perform any business-logic composition beyond executing the single patch request.
- If multiple patch requests are needed (multiple domains or multiple sequential patches), they **MUST** be composed in **Reconcile methods** as multiple explicit patch operations (each with its own `base` taken immediately before that patch).
- A **PatchReconcileHelper** **MUST NOT** call other **ReconcileHelpers**.

---

## Flow phases and **Outcome**

- **PatchReconcileHelpers** **MUST NOT** create a `reconcile/flow` **phase** — they should stay mechanical and short.
- If a **PatchReconcileHelper** returns **Outcome** (in code: `flow.Outcome`), it **SHOULD** use helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.
  - Prefer encoding retry/requeue policy explicitly in the returned **Outcome**.

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- A **PatchReconcileHelper** **SHOULD** be mechanically thin: if the single patch call fails, return the error **without wrapping**.
  - If returning **Outcome** (in code: `flow.Outcome`), use `flow.Fail(err)` (or equivalent) with the original `err`.
- A **PatchReconcileHelper** **MUST NOT** enrich errors with additional context (including **object identity** such as `namespace/name`, UID, object key).
  - Error enrichment (action + **object identity** + **phase**) is the calling **Reconcile method**’s responsibility.

---

## Common anti-patterns (**MUST NOT**)

❌ Doing any Kubernetes API calls other than the single patch request (`Get/List/Create/Update/Delete`, or a second patch):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: extra API call
    var cur v1alpha1.EON
    if err := r.client.Get(ctx, client.ObjectKeyFromObject(obj), &cur); err != nil {
        return err
    }

    // forbidden: patch after an extra call (still >1 API call in helper)
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Calling `DeepCopy` inside patch helpers (the caller creates `base`):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Patching a temporary copy and dropping it (caller-owned `obj` stays stale):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    tmp := obj.DeepCopy() // also forbidden: DeepCopy in patch helper
    if err := r.client.Patch(ctx, tmp, client.MergeFrom(base)); err != nil {
        return err
    }
    // forbidden: obj is not updated with new resourceVersion/defaults
    return nil
}
```

❌ Patching both patch domains in one helper:
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: two requests / two domains
    if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // main
        return err
    }
    return r.client.Status().Patch(ctx, obj, client.MergeFrom(base)) // status
}
```

❌ Making patch ordering decisions (patch helpers execute exactly one patch, ordering lives in Reconcile methods):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: deciding to patch status first / mixing ordering policy into the helper
    if needsStatus(obj) {
        if err := r.client.Status().Patch(ctx, obj, client.MergeFrom(base)); err != nil {
            return err
        }
    }
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Overriding the caller’s optimistic-locking decision:
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    optimisticLock = true // forbidden: helper must not change the decision
    // ...
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Performing business-logic mutations inside the patch helper (beyond the patch call itself):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    // forbidden: business mutations belong to compute/apply/ensure before calling patch
    obj.Spec.Replicas = 3
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Mutating `base` (it is read-only diff reference):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    labels := base.GetLabels()
    labels["x"] = "y" // forbidden: mutates base via alias
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Hidden I/O / nondeterminism (time/random/env/extra network calls):
```go
func (r *Reconciler) patchEON(ctx context.Context, obj, base *v1alpha1.EON, optimisticLock bool) error {
    if os.Getenv("PATCH_FAST") == "1" { // forbidden: env read in helper
        // ...
    }
    _ = time.Now() // forbidden
    return r.client.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Using broad patch helpers that patch multiple objects (must patch exactly one object instance):
```go
func (r *Reconciler) patchEONs(ctx context.Context, objs []*v1alpha1.EON, base *v1alpha1.EON, optimisticLock bool) error {
    for _, obj := range objs {
        if err := r.client.Patch(ctx, obj, client.MergeFrom(base)); err != nil { // forbidden: multiple API calls
            return err
        }
    }
    return nil
}
```
