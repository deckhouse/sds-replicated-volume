---
description: Reconciliation flow usage — phases and Outcome composition
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# flow usage patterns (phases + outcomes)

This document defines the **usage contract** for `internal/reconciliation/flow` in controller reconciliation code:
how to structure work into **phases** and how to compose/propagate `flow.Outcome` (including error boundaries via
`OnErrorf`) without duplicate logging.

It complements `controller-reconciliation.mdc` (orchestration rules) and `controller-reconcile-helper*.mdc`
(helper-category contracts). Scope: **flow mechanics only** — phase lifecycle rules, naming, and outcome composition
patterns. This document intentionally does **NOT** define domain-specific reconciliation logic, reconciliation
patterns, or helper I/O boundaries beyond what is necessary to apply `flow` correctly.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

- **0 or 1 phase per function**. If phased: **no** nested/sequential phases, **no** phases in loops.
- Phased function = **2-line header**:
  1) `ctx, log := flow.BeginPhase(...)` (first executable line)
  2) `defer flow.EndPhase(ctx, &outcome)` (second line)
  Nothing before/between.
- Returns: named return **only** `outcome flow.Outcome`; `EndPhase(ctx, &outcome)` **only**; **no bare `return`**.
- Context/logger: use **only derived `ctx`**, pass **unchanged**; if logging, use **only** `log` from `BeginPhase` (no `log.FromContext`, no mixed loggers).
- Steps: `outcome = step(...).OnErrorf(ctx, "...")` then **immediately** `if outcome.ShouldReturn(){ return outcome }`. No reorder, no skipping the check, no double `OnErrorf`.
- Composition: **sequential** if ordering/early-exit matters; `Merge` only if all steps must run; loops → collect `outcomes` then `flow.Merge(outcomes...)`.
- Naming: `outcome`/`outcomes`; phase name = stable lowercase ASCII id (`a–z0–9` + `.`/`-`), **no** dynamic parts; variable context → `BeginPhase` metadata.

---

## ALLOW / DENY cheat sheet

**ALLOW (MAY):**
- Use **phases** (`flow.BeginPhase` / `flow.EndPhase`) **only in “phased” functions** (exactly one phase per function).
- If a function is phased, it MAY:
  - call `ctx, log := flow.BeginPhase(ctx, "phase-name", "k", v, ...)` on the **first executable line**,
  - `defer flow.EndPhase(ctx, &outcome)` on the **second line**,
  - use a **named return** `outcome flow.Outcome` and pass `&outcome` to `EndPhase`.
- Use the **derived** `ctx` returned by `BeginPhase` for **all** work in the function and pass it **unchanged** to all helpers.
- If the function logs anything, use **only** the logger returned by `BeginPhase`.
  - Ignoring the logger (`_`) is allowed if the function does **no logging**.
- Add **local error boundaries** at step call-sites using `OnErrorf(ctx, "...")`:
  - `outcome = step(...).OnErrorf(ctx, "ensure foo")`
  - immediately followed by: `if outcome.ShouldReturn() { return outcome }`
- Compose steps explicitly and reviewably:
  - **Sequential pattern** when ordering or early-stop matters.
  - **Merge pattern** only when all steps must run regardless of others.
  - Loop pattern: collect `outcomes := []flow.Outcome{...}` and then `outcome := flow.Merge(outcomes...)`.
- Attach variable context via **phase metadata**, not via phase names:
  - `flow.BeginPhase(ctx, "ensureChild", "child", child.Name)`
- Use stable, identifier-like phase names suitable for `logr.WithName`:
  - lowercase ASCII, characters `a–z0–9`, separators `.` and `-`.

**DENY (MUST NOT):**
- Start **more than one phase** in the same function (nested or sequential phases are forbidden).
- Start a phase **inside a loop** in the same function.
- Place **any statements** before `BeginPhase`, or **any statements** between `BeginPhase` and `defer EndPhase`
  (including declarations, logging, conditionals).
- Use any named return other than `outcome` in phased functions.
- Pass anything other than `&outcome` into `flow.EndPhase`.
- Use **bare `return`** (empty return), even with named return values.
- Use the original/incoming `ctx` after `BeginPhase`.
- Replace or mutate the derived phase context
  (`ctx = context.WithValue(...)`, `ctx = otherCtx`, etc.).
- Use `log.FromContext(ctx)` or any other logger inside a phased function.
- Mix multiple loggers inside a phased function.
- Log the same error more than once:
  - MUST NOT log error details manually if `OnErrorf` is used at the call site.
  - MUST NOT rely on `EndPhase` for error details (it logs only a summary).
- Mis-order error boundary and decision logic:
  - MUST NOT check `ShouldReturn()` **before** calling `OnErrorf`.
  - MUST NOT call `OnErrorf` and then continue execution without a `ShouldReturn()` check.
  - MUST NOT apply `OnErrorf` more than once for the same step/boundary.
- Use unstable or invalid phase names:
  - empty names,
  - names with spaces or control characters,
  - names containing dynamic values (IDs, resource names, loop indices).
- Encode metadata into the phase name instead of structured metadata arguments.
- Use `Merge` when early-stop or ordering semantics matter (merge does not short-circuit).

**DISCOURAGED (SHOULD NOT):**
- “Single-shot” mega-merge hiding intent and ordering:
  - `flow.Merge(stepA(...), stepB(...), stepC(...))`
- Inline `Wrapf` inside merge operands; prefer `OnErrorf` per step and apply outer context *after* merging.
- Best-effort loops that ignore outcomes, unless explicitly justified with a comment explaining why it is safe.

---

## Error handling & logging

### Use `OnErrorf` as the boundary helper (SHOULD)

```go
outcome = r.ensureFoo(ctx, obj).OnErrorf(ctx, "ensure foo")
if outcome.ShouldReturn() {
    return outcome
}
```

Rules:
- `OnErrorf` logs exactly once
- adds local context
- wraps with phase metadata for upward propagation

### Avoid duplicate error logs (MUST)

- `OnErrorf` logs error details
- `EndPhase` logs only summary (`hasError`, `result`, `duration`)
- do not log the same error again

---

## Phase usage

A phase is a **scoped reconciliation block** started with `flow.BeginPhase` and **always** closed with `flow.EndPhase`. Phases define the logging, error attribution, and lifecycle boundaries for a reconciliation step.

This section defines **strict rules** for using phases.

---

### Single-phase rule (MUST)

- If a function uses a phase, it **MUST use exactly one phase**.
- A function **MUST NOT** start more than one phase.
- Nested or sequential phases inside the same function are **NOT allowed**.

A function is either:
- **phased** (exactly one `BeginPhase` / `EndPhase` pair), or
- **non-phased** (no phase at all).

There is no intermediate or mixed mode.

---

### Phase placement (MUST)

If a function uses a phase:

- `flow.BeginPhase` **MUST** be called on the **first executable line** of the function.
- `defer flow.EndPhase(...)` **MUST** be the **second line**.
- No other statements (including variable declarations, logging, or conditionals) are allowed before `BeginPhase` or between `BeginPhase` and `defer EndPhase`.

This guarantees that:
- the entire function body is covered by the phase,
- all early returns are properly finalized,
- logs and errors are consistently attributed.

---

### Required return variable (MUST)

- Any phased function **MUST**:
  - use a **named return value** named `outcome`,
  - pass **a pointer to that variable** into `flow.EndPhase`.
- Bare `return` (empty return) is **forbidden** — always return explicitly:
  - `return outcome` (or `return outcome, value` for multi-return functions).

```go
func (...) (...) (outcome flow.Outcome)
```

```go
defer flow.EndPhase(ctx, &outcome)
```

Using a different variable name or passing a temporary value is **NOT allowed**.

---

### Context and logger handling (MUST)

- `flow.BeginPhase` returns **two values**:
  1. a derived `context.Context`,
  2. a **phase-scoped logger**.
- If a function starts a phase, it **MUST**:
  - use the returned `ctx` for **all** subsequent operations inside the function, and
  - pass that `ctx` **unchanged** to all helper calls.
- If the function performs **any logging**, it **MUST**:
  - capture the returned logger, and
  - use **only that logger** for all logs in the function.

Rules:

- The original (incoming) context **MUST NOT** be used after `BeginPhase`.
- Ignoring the logger (`_`) is allowed **only if the function does not log anything**.
- Using `log.FromContext(ctx)` or any other logger inside a phased function is **NOT allowed**.
- Mixing multiple loggers inside a phased function is **NOT allowed**.
- Helper functions called from a phased function **MUST** receive the derived `ctx`, so that:
  - logs are attributed to the correct phase,
  - cancellation, deadlines, and values propagate consistently.


---

### Canonical templates (MUST)

#### Phased function without logging

```go
func doWork(ctx context.Context) (outcome flow.Outcome) {
    ctx, _ = flow.BeginPhase(ctx, "do-work")
    defer flow.EndPhase(ctx, &outcome)

    outcome = flow.Continue()
    return outcome
}
```

#### Phased function with logging

```go
func doWork(ctx context.Context, input string) (outcome flow.Outcome) {
    ctx, log := flow.BeginPhase(ctx, "do-work", "input", input)
    defer flow.EndPhase(ctx, &outcome)

    log.Info("phase doing smthg")

    return flow.Continue()
}
```

---

### Phase name and metadata

The phase name is used as a **logger name segment** via:

```
log.FromContext(ctx).WithName(phaseName)
```

Because of this, strict naming rules apply.

#### Phase name rules (MUST)

- The phase name **MUST NOT** be empty.
- The phase name **MUST NOT** contain:
  - spaces,
  - control characters,
  - newline or tab characters.
- The phase name **MUST** be a single, stable identifier suitable for `logr.WithName`.
- The phase name **SHOULD** be:
  - lowercase,
  - ASCII-only,
  - composed of readable segments.

Recommended character set:

- `a–z`, `0–9`
- separators: `.` and `-`

#### Structure and stability (SHOULD)

- The phase name **MUST** be a logical step name.
- The phase name **MUST NOT** include:
  - dynamic values,
  - resource names,
  - IDs, UIDs, or loop indices.

Reasoning:
- `WithName` composes logger names hierarchically (joined by dots).
- Dynamic or unstable names break log aggregation, filtering, and long-term diagnostics.

#### Metadata vs name (MUST)

- Variable or contextual information **MUST NOT** be encoded in the phase name.
- Such information **MUST** be passed as structured metadata to `BeginPhase`:

```
flow.BeginPhase(ctx, "ensureChild", "child", child.Name)
```

Rule of thumb:

- **Name** = stable *what*
- **Metadata** = variable *which*

Violating this rule is considered a logging contract break.

---

## Step composition with Outcome

This section defines how to compose reconciliation **steps** that return `flow.Outcome`. The goal is predictable control-flow, single error logging, and reviewable orchestration.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

### Core idea

A step returns a `flow.Outcome`. Composition is built around three operations:

- Add a **local error boundary**: `OnErrorf(ctx, "...")` (SHOULD)
- Decide whether to **exit early**: `ShouldReturn()` (MUST)
- Combine **independent** results: `Merge(...)` / `flow.Merge(...)` (MAY)

---

### Naming rules (MUST)

- Inside phased functions (those with `BeginPhase` / `EndPhase`), the named return value **MUST** be `outcome`.
- When collecting multiple results, the slice variable **MUST** be `outcomes`.
- In tiny local scopes (no phase), short name `o` **MAY** be used for a single `flow.Outcome`.

---

### Error boundary and early-exit (MUST / SHOULD)

- Each step that can fail / requeue / stop **SHOULD** be wrapped at the call site using:
  - `OnErrorf(ctx, "...")` to log exactly once and attach local context.
- After applying `OnErrorf`, callers **MUST** check:
  - `if outcome.ShouldReturn() { return outcome }`
  - Bare `return` (empty return) is **forbidden**, even with named return values.
  - For multi-return functions: `if outcome.ShouldReturn() { return outcome, value }`


Logging rules:

- `OnErrorf` logs the error details exactly once and adds local context.
- `EndPhase` logs only a summary (`hasError`, `result`, `duration`).
- Therefore you **MUST NOT** log the same error again elsewhere.

---

### Pattern A: Sequential steps (ordering matters)

**MUST** be used when early-stop or ordering matters.

Use when:
- order matters,
- later steps depend on outputs of earlier steps,
- an error or stop must short-circuit execution.

Canonical form:

```go
outcome := stepA(...).OnErrorf(ctx, "step A")
if outcome.ShouldReturn() {
    return outcome
}

outcome, foo := stepB(...)
outcome = outcome.OnErrorf(ctx, "step B")
if outcome.ShouldReturn() {
    return outcome
}

outcome = stepC(foo, ...).OnErrorf(ctx, "step C")
return outcome
```

Inline form (**MAY**, use sparingly):

```go
if outcome := stepA(...).OnErrorf(ctx, "step A"); outcome.ShouldReturn() {
    return outcome
}

outcome, foo := stepB(...)
outcome = outcome.OnErrorf(ctx, "step B")
if outcome.ShouldReturn() {
    return outcome
}

return stepC(foo, ...).OnErrorf(ctx, "step C")
```

---

### Pattern B: Independent steps (merge; all steps must run)

**MAY** be used only when every step must execute regardless of others.

```go
outcome := stepA(...).OnErrorf(ctx, "step A")

outcome = outcome.Merge(
    stepB(...).OnErrorf(ctx, "step B"),
)

outcome = outcome.Merge(
    stepC(...).OnErrorf(ctx, "step C"),
)

return outcome
```

Important:

- If early-stop matters → you **MUST** use the sequential pattern.
- `Merge` does **not** short-circuit execution; it only combines outcomes.

---

### Pattern C: Many objects (collect + merge)

**SHOULD** be used for loops over items.

```go
outcomes := make([]flow.Outcome, 0, len(items))
for i := range items {
    item := &items[i]
    o := ensureOne(item).OnErrorf(ctx, "item %s", item.Name)
    outcomes = append(outcomes, o)
}

outcome := flow.Merge(outcomes...)
return outcome
```

Optional outer context (**MAY**):

```go
outcome := flow.Merge(outcomes...).Wrapf("ensure items")
return outcome
```

---

### Pattern D: Best-effort loops (RARE)

**MUST** be explicitly justified with a comment.

```go
for i := range items {
    item := &items[i]
    _ = ensureOne(item).OnErrorf(ctx, "best-effort ensure %s", item.Name)
}

// MUST: explain why best-effort is acceptable here.
return flow.Continue()
```

---

### Steps returning extra values

When a function returns `(outcome, value)`, early-exit rules **MUST** still be followed.

```go
func (r *Reconciler) computeSomething(ctx context.Context) (outcome flow.Outcome, value string) {
    ctx, _ = flow.BeginPhase(ctx, "computeSomething")
    defer flow.EndPhase(ctx, &outcome)

    outcome, value = doCompute(...)
    outcome = outcome.OnErrorf(ctx, "do compute")
    if outcome.ShouldReturn() {
        return outcome, value
    }

    return flow.Continue(), value
}
```

---

### Discouraged compositions

**SHOULD NOT**:

- Single-shot merge (allowed, but hard to review):

```go
outcome := flow.Merge(stepA(...), stepB(...), stepC(...))
return outcome
```

- Inline `Wrapf` inside merge (BAD):

```go
outcome := flow.Merge(
    stepA(...).Wrapf("A"),
    stepB(...).Wrapf("B"),
)
return outcome
```

Prefer `OnErrorf` at step boundaries and apply any outer context *after* merging (e.g. `.Wrapf("ensure items")`).

## Common anti-patterns (MUST NOT)

❌ **Logging the same error twice** (manual log + `OnErrorf`):

    func (r *Reconciler) ensureStuff(ctx context.Context, obj *v1alpha1.Foo) (outcome flow.Outcome) {
        ctx, log := flow.BeginPhase(ctx, "ensureStuff")
        defer flow.EndPhase(ctx, &outcome)

        outcome = r.ensureFoo(ctx, obj).OnErrorf(ctx, "ensure foo")
        if outcome.ShouldReturn() {
            // forbidden: OnErrorf already logged the error details
            log.Error(fmt.Errorf("some error"), "ensure foo failed (duplicate)")
            return outcome
        }

        return flow.Continue()
    }

---

❌ **Logging inside a step and again at the call-site boundary** (`OnErrorf`):

    func (r *Reconciler) ensureFoo(ctx context.Context, obj *v1alpha1.Foo) (outcome flow.Outcome) {
        ctx, log := flow.BeginPhase(ctx, "ensureFoo")
        defer flow.EndPhase(ctx, &outcome)

        if err := r.doFoo(ctx, obj); err != nil {
            // forbidden: step logs error details
            log.Error(err, "do foo failed")
            return flow.Error(err)
        }

        return flow.Continue()
    }

    func (r *Reconciler) ensureStuff(ctx context.Context, obj *v1alpha1.Foo) (outcome flow.Outcome) {
        ctx, _ = flow.BeginPhase(ctx, "ensureStuff")
        defer flow.EndPhase(ctx, &outcome)

        // forbidden: caller logs again via OnErrorf
        outcome = r.ensureFoo(ctx, obj).OnErrorf(ctx, "ensure foo")
        if outcome.ShouldReturn() {
            return outcome
        }

        return flow.Continue()
    }

---

❌ **Calling `OnErrorf` without mandatory early-exit check**:

    func (r *Reconciler) ensureStuff(ctx context.Context, obj *v1alpha1.Foo) (outcome flow.Outcome) {
        ctx, _ = flow.BeginPhase(ctx, "ensureStuff")
        defer flow.EndPhase(ctx, &outcome)

        _ = r.ensureFoo(ctx, obj).OnErrorf(ctx, "ensure foo") // forbidden
        _ = r.ensureBar(ctx, obj).OnErrorf(ctx, "ensure bar") // forbidden

        return flow.Continue()
    }

---

❌ **Checking `ShouldReturn()` before applying `OnErrorf`**:

    outcome = r.ensureFoo(ctx, obj)
    if outcome.ShouldReturn() { // forbidden
        return outcome
    }

    outcome = outcome.OnErrorf(ctx, "ensure foo")

---

❌ **Applying `OnErrorf` more than once for the same step**:

    outcome = r.ensureFoo(ctx, obj).OnErrorf(ctx, "ensure foo")
    outcome = outcome.OnErrorf(ctx, "ensure foo again") // forbidden

---

❌ **Starting more than one phase in the same function**:

    func (r *Reconciler) ensureStuff(ctx context.Context) (outcome flow.Outcome) {
        ctx, _ = flow.BeginPhase(ctx, "ensureStuff")
        defer flow.EndPhase(ctx, &outcome)

        ctx, _ = flow.BeginPhase(ctx, "ensureMoreStuff") // forbidden
        defer flow.EndPhase(ctx, &outcome)

        return flow.Continue()
    }

---

❌ **Starting phases inside a loop**:

    for i := range items {
        ctx, _ = flow.BeginPhase(ctx, "ensureOne") // forbidden
        defer flow.EndPhase(ctx, &outcome)
    }

---

❌ **Violating phase placement rules**:

    func (r *Reconciler) ensureFoo(ctx context.Context) (outcome flow.Outcome) {
        if ctx == nil { // forbidden: code before BeginPhase
            return flow.Error(fmt.Errorf("nil ctx"))
        }

        ctx, _ = flow.BeginPhase(ctx, "ensureFoo")
        log.Info("started") // forbidden: code between BeginPhase and defer

        defer flow.EndPhase(ctx, &outcome)
        return flow.Continue()
    }

---

❌ **Not deferring `EndPhase`**:

    ctx, _ = flow.BeginPhase(ctx, "ensureFoo")
    // forbidden: EndPhase is not deferred
    return flow.Continue()

---

❌ **Using a named return other than `outcome`**:

    func ensureFoo(ctx context.Context) (res flow.Outcome) { // forbidden
        ctx, _ = flow.BeginPhase(ctx, "ensureFoo")
        defer flow.EndPhase(ctx, &res)
        return flow.Continue()
    }

---

❌ **Passing a wrong pointer to `EndPhase`**:

    tmp := outcome
    defer flow.EndPhase(ctx, &tmp) // forbidden

---

❌ **Bare `return` in phased functions**:

    if outcome.ShouldReturn() {
        return // forbidden
    }

---

❌ **Using the original context after `BeginPhase`**:

    incoming := ctx
    ctx, _ = flow.BeginPhase(ctx, "ensureFoo")

    _ = r.ensureBar(incoming) // forbidden

---

❌ **Using `log.FromContext(ctx)` inside phased functions**:

    log.FromContext(ctx).Info("hello") // forbidden

---

❌ **Mixing multiple loggers in one phased function**:

    ctx, log := flow.BeginPhase(ctx, "ensureFoo")
    other := ctrl.Log.WithName("ensureFoo")
    other.Info("oops") // forbidden

---

❌ **Mutating the derived phase context**:

    ctx = context.WithValue(ctx, "x", 1) // forbidden

---

❌ **Invalid or unstable phase names**:

    flow.BeginPhase(ctx, "ensure foo")                 // forbidden
    flow.BeginPhase(ctx, fmt.Sprintf("ensure-%s", id)) // forbidden

---

❌ **Encoding metadata into the phase name**:

    flow.BeginPhase(ctx, "ensureChild."+child.Name) // forbidden

---

❌ **Using `Merge` when early-stop or ordering matters**:

    outcome = flow.Merge(
        stepA(ctx).OnErrorf(ctx, "A"),
        stepB(ctx).OnErrorf(ctx, "B"),
    ) // forbidden

---

❌ **Best-effort loop without explicit justification**:

    for i := range items {
        _ = ensureOne(ctx, &items[i]).OnErrorf(ctx, "best-effort")
        // forbidden: missing comment explaining why best-effort is acceptable
    }
