---
description: Contracts for IsInSyncReconcileHelper (is*InSync*) functions: tiny pure/deterministic non-I/O equality checks per patch domain. Apply when writing is*InSync* helpers in reconciler*.go, and when deciding how to gate patches deterministically. Apply when editing relevant files, and when reasoning/planning/answering questions where this rule could influence code decisions (even if matching files are not currently open).
globs: images/controller/internal/controllers/rv_controller/reconciler*.go,images/controller/internal/controllers/rv_attach_controller/reconciler*.go
alwaysApply: false
---

See `rfc-like-mdc.mdc` for normative keywords (BCP 14 / RFC 2119 / RFC 8174) and general .mdc writing conventions.

# IsInSyncReconcileHelper

This document defines naming and contracts for **IsInSyncReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **IsInSyncReconcileHelpers** (`is*InSync`) are tiny, **pure**, **deterministic**, strictly **non-I/O** boolean checks.
- They compare the current `obj` state to a single **target** (and/or **report**) value for **exactly one** **patch domain** (**main patch domain** or **status patch domain**) and return `true/false`.
- For status **report/observations**, the compared “**report**” value MAY be directly reused from selected **actual** observations (including being the same value/type as an **actual** snapshot) when publishing observations verbatim to `.status`.
- They SHOULD NOT return errors, MUST NOT do reconcile flow control (**ReconcileOutcome**), and MUST NOT log.
- They treat `obj` and `target` / `report` as **read-only inputs** (no mutations, including via map/slice **Aliasing**; **Clone** before any normalization).

---

## Definition

An **IsInSyncReconcileHelper** (“in-sync helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- checks whether the current object state is already equal to the intended **target** (and/or published **report**) for **exactly one patch domain** (**main resource** or **status subresource**), and
- returns a boolean result.

Typical in-sync helpers gate patch execution by answering “do we need to patch this domain?” for a single **target**/**report** input.

---

## Naming

- An **IsInSyncReconcileHelper** name MUST start with `is` / `Is` and MUST contain `InSync`.
- **IsInSyncReconcileHelpers** MUST be domain-explicit in the name when ambiguity is possible (ambiguity is possible when the checked “thing” name refers to a field/group that exists in both `.spec` (**main patch domain**) and `.status` (**status patch domain**) of the same **object**):
  - `isMain*InSync` / `IsMain*InSync` / `is*MainInSync` / `Is*MainInSync`
  - `isStatus*InSync` / `IsStatus*InSync` / `is*StatusInSync` / `Is*StatusInSync`
- **IsInSyncReconcileHelpers** SHOULD NOT include `Main` / `Status` in the name when there is no such ambiguity.
- **IsInSyncReconcileHelpers** names MUST NOT include `Desired` / `Actual` / `Intended` / `Target` / `Report` unless the checked “thing” name in the **object** API includes those words.
- **IsInSyncReconcileHelpers** names SHOULD name the “thing” being checked for drift:
  - `isLabelsInSync(obj, targetLabels)`
  - `isSpecFooInSync(obj, targetFoo)`
  - `isStatusInSync(obj, targetStatus)` (ok when status is small; otherwise prefer artifact-specific checks)
  - `isConditionsInSync(obj, reportConditions)` (when checking published **report** conditions)
- **IsInSyncReconcileHelpers** names SHOULD NOT be generic (`isInSync`, `isEverythingInSync`) — the name should communicate the **patch domain** + artifact being compared.

---

## Preferred signatures

- For **IsInSyncReconcileHelpers** (`is*InSync`), the simplest signature from the variants below that preserves explicit dependencies and purity SHOULD be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they MAY also be used.

### Simple check (no flow, no logging)
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool
```

---

## Receivers

- **IsInSyncReconcileHelpers** MUST be plain functions (no `Reconciler` receiver).

---

## I/O boundaries

**IsInSyncReconcileHelpers** MUST NOT do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

**IsInSyncReconcileHelpers** MUST NOT do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: in-sync helpers should be **deterministic** and unit-testable; all observable side effects belong to **Reconcile methods**.

---

## Determinism contract

An **IsInSyncReconcileHelper** MUST be **deterministic** given its explicit inputs and read-only dependencies.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular, avoid producing “equivalent but different” intermediate representations across runs (e.g., unstable ordering that flips the boolean result depending on traversal).

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract

`is*InSync` / `Is*InSync` MUST treat all inputs as read-only:

- it MUST NOT mutate any input values (including `obj`, `target` / `report`, and any other args);
- it MUST NOT perform in-place modifications through aliases.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- `is*InSync` / `Is*InSync` MUST check **exactly one** patch domain:
  - **main resource** (**metadata + spec + non-status fields**), **or**
  - **status subresource** (`.status`).
- If you need to check both domains, you MUST use **two** separate helpers (one per **patch domain**), and combine the results in **Reconcile methods**.

✅ Main-only / status-only (GOOD)
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFooMain) bool
func isFooStatusInSync(obj *v1alpha1.Foo, report FooReport) bool
```

❌ Mixed domains in one helper (BAD)
```go
func isFooInSync(
    obj *v1alpha1.Foo,
    targetMain TargetFooMain,
    report FooReport,
) bool
```

---

## Composition

- An **IsInSyncReconcileHelper** MUST stay a single, simple check: it returns exactly one boolean for one **target**/**report** input.
- If multiple “pieces” must be checked together for the same domain, they SHOULD be bundled into a single `target` / `report` value (small struct) and checked in one helper.
- An **IsInSyncReconcileHelper** MAY call other `is*InSync` helpers for reuse (pure composition).
  - It SHOULD NOT use such calls to compose independent checks; independent checks should be composed in Reconcile methods.
- If checks are meaningfully independent and will be used separately, they SHOULD be split into separate `is*InSync` helpers and composed in Reconcile methods (not inside the helper).
- An **IsInSyncReconcileHelper** MUST NOT call **ReconcileHelpers** from other **Helper categories**.

---

## Flow phase scopes and outcomes

- **IsInSyncReconcileHelpers** MUST NOT create a `reconcile/flow` **phase scope** (they do not accept `ctx context.Context`; see `controller-reconcile-helper.mdc`).
- **IsInSyncReconcileHelpers** MUST NOT return **ReconcileOutcome** (`flow.ReconcileOutcome`) or **EnsureOutcome** (`flow.EnsureOutcome`) (they are pure checks).
  - If you need flow control (requeue, done, fail), keep it in the caller and/or use other helper categories (e.g., compute/ensure/patch).
- **IsInSyncReconcileHelpers** MUST NOT log.

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- **IsInSyncReconcileHelpers** SHOULD be designed to be non-failing (pure checks).
  - If an error is realistically possible, prefer handling it in a **ComputeReconcileHelper** (or in the caller) and pass only validated/normalized inputs to `is*InSync`.
- **IsInSyncReconcileHelpers** MUST NOT create/wrap/enrich errors, and MUST NOT include **object identity** (e.g. `namespace/name`, UID, object key).
- Do **not** log and also return a “failure signal” for the same condition unless the surrounding reconcile style explicitly requires it (avoid duplicate logs).

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API I/O (directly or indirectly):
```go
// forbidden shape: IsInSync helpers MUST NOT accept ctx (no I/O allowed)
// forbidden: IsInSync helpers MUST be plain functions (no Reconciler receiver)
func (r *Reconciler) isFooInSync(ctx context.Context, obj *v1alpha1.Foo, target TargetFoo) bool {
    // forbidden: I/O in IsInSync helper
    var cm corev1.ConfigMap
    key := client.ObjectKey{Namespace: obj.Namespace, Name: "some-cm"}
    _ = r.client.Get(ctx, key, &cm)
    return true
}
```

❌ Returning `error` as part of the signature when it is avoidable:
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) (bool, error) { // avoid
    return true, nil
}
```

❌ Doing flow control / returning `flow.Outcome`:
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) flow.ReconcileOutcome { // forbidden
    var rf flow.ReconcileFlow
    return rf.Continue()
}
```

❌ Logging or creating phases (no `ctx`, no logs):
```go
// forbidden: IsInSync helpers MUST NOT accept ctx (they must stay pure and non-logging)
func isFooInSync(ctx context.Context, obj *v1alpha1.Foo, target TargetFoo) bool {
    l := log.FromContext(ctx)
    l.Info("checking in-sync") // forbidden: no logging in IsInSync helpers
    return true
}
```

❌ Calling `DeepCopy`:
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    _ = obj.DeepCopy() // forbidden
    return true
}
```

❌ Mutating `obj` (even “harmless” changes):
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    obj.Spec.Replicas = target.Replicas // forbidden: IsInSync is read-only
    return false
}
```

❌ Mutating `target` / `report`:
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    target.Replicas = 3 // forbidden: target is read-only
    return obj.Spec.Replicas == target.Replicas
}
```

❌ Mutating through aliasing (maps/slices from inputs):
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    ids := obj.Spec.IDs
    slices.Sort(ids) // forbidden: sorts in place and mutates obj
    return true
}
```

❌ Depending on map iteration order (nondeterministic boolean):
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    // obj.Spec.Flags is a map[string]bool
    got := make([]string, 0, len(obj.Spec.Flags))
    for k := range obj.Spec.Flags { // map iteration order is random
        got = append(got, k)
    }
    // comparing to target.Keys without sorting => nondeterministic result
    return reflect.DeepEqual(got, target.Keys)
}
```

❌ Checking both patch domains in one helper:
```go
func isFooInSync(obj *v1alpha1.Foo, target TargetFoo) bool {
    // forbidden: mixes main + status checks
    mainOK := obj.Spec.Replicas == target.Replicas
    statusOK := obj.Status.Phase == target.Phase
    return mainOK && statusOK
}
```
