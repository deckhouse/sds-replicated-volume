---
description: Controller reconciliation helpers — EnsureReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# EnsureReconcileHelper

This document defines naming and contracts for **EnsureReconcileHelper** functions/methods.

Common terminology and rules for any ReconcileHelper live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

- `ensure*` helpers are **pure, deterministic, strictly non-I/O** in-place mutation steps for **exactly one patch domain** (main **or** status).
- They mutate the caller-owned `obj` and return a `flow.Outcome` that encodes:
  - whether `obj` was changed,
  - whether the subsequent save **requires optimistic locking**,
  - and whether an error occurred.
- They **MUST NOT** use controller-runtime client, talk to the Kubernetes API, call `DeepCopy`, or execute patches / make patch ordering decisions.
- If both main and status need changes, split into **two** ensure helpers (one per domain) and patch them separately in Reconcile methods.

---

## ALLOW / DENY cheat sheet

**ALLOW (MAY):**
- Mutate the caller-owned `obj` **in place** to “make it more correct” for **exactly one** patch domain:
  - main resource (metadata/spec/non-status), **or**
  - status subresource (`.status`).
- Make step-by-step, imperative corrections (set/clear fields, normalize formats, add/remove elements) as long as they are deterministic.
- Use `objutilv1` (imported as `obju`) for labels/annotations/finalizers/ownerRefs/conditions operations where required by the codebase.
- If you need stable ordering (finalizers, ownerRefs, conditions, slices derived from maps/sets), **sort/canonicalize** before writing to `obj`.
- Return `flow.Outcome` that encodes (via the `flow.Outcome` API):
  - “changed” when and only when `obj` was actually mutated,
  - “requires optimistic locking” when and only when the subsequent save must use optimistic locking,
  - error state when something prevents correct reconciliation.
- Compose other pure helpers:
  - call other `ensure*` helpers for sub-steps,
  - depend on prior compute results by taking them as explicit args **after `obj`**.
- If the logic is complex and needs logging/phase boundaries, accept `ctx context.Context` and start a phase; keep it non-I/O.
- Read reconciler-owned **pure** config/components (templates, scorers, planners, caches) only if they do not perform I/O and results are deterministic for the same explicit inputs and the same internal state.

**DENY (MUST NOT):**
- Any controller-runtime client usage or Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`), directly or indirectly.
- `DeepCopy` in any form (`obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.).
- Executing patches (`Patch` / `Status().Patch`) or making patch ordering / patch type decisions.
- Mutating both patch domains in the same helper (main + status together).
- Mutating any inputs other than `obj` (desired structs, templates/defaults, previously computed values), including via aliasing of maps/slices.
- Hidden I/O / nondeterminism:
  - `time.Now()` / `time.Since(...)` (except condition timestamps set indirectly via `obju` helpers where unavoidable),
  - `rand.*` / UUID generation,
  - `os.Getenv`, reading files,
  - network calls of any kind.
- Depending on map iteration order when producing ordered output (must sort before writing).
- Returning an outcome that contradicts reality:
  - reporting “changed” without a mutation,
  - mutating `obj` without reporting “changed”,
  - setting optimistic-lock requirement nondeterministically or without a clear, deterministic reason.

---

## Definition (MUST)

An **EnsureReconcileHelper** (“ensure helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- performs in-place “make it more correct” mutations on the object for **exactly one patch domain** (main resource **or** status subresource), and
- returns a `flow.Outcome` that reports whether it changed the object, whether optimistic locking is required for the save operation (if any), and whether an error occurred.

Typical ensure helpers implement step-by-step in-place reconciliation and return `flow.Outcome` (e.g., via `flow.Continue().ReportChanged()`, `flow.ContinueErr(...)`, `flow.Done()`, `flow.Fail(err)`, etc.) to drive patching decisions in Reconcile methods.

---

## Naming (MUST)

- An **EnsureReconcileHelper** name **MUST** start with `ensure` / `Ensure`.
- EnsureReconcileHelpers **MUST** be domain-explicit in the name when ambiguity is possible:
  - `ensureMain*` / `EnsureMain*` (main resource)
  - `ensureStatus*` / `EnsureStatus*` (status subresource)

Guidance (SHOULD):
- Name the invariant or property being ensured:
  - `ensureFinalizer(...)`
  - `ensureOwnerRefs(...)`
  - `ensureDesiredLabels(...)`
  - `ensureStatusConditions(...)`
- Avoid “orchestrator-sounding” names (`ensureAll`, `ensureEverything`, `ensureAndPatch`) — ensure helpers do not execute I/O; they only mutate and return `flow.Outcome`.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and flow semantics.

### Simple ensure (SHOULD)
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureFoo(obj *v1alpha1.Foo) flow.Outcome
```

### Ensure with logging / phases (SHOULD)
```go
func ensureFoo(
    ctx context.Context,
    obj *v1alpha1.Foo,
) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureFoo(
    ctx context.Context,
    obj *v1alpha1.Foo,
) flow.Outcome
```

### Dependent ensure (MUST)
Dependencies **MUST** be explicit and come **after `obj`**:
```go
func ensureBar(
    ctx context.Context,
    obj *v1alpha1.Foo,
    desiredFoo DesiredFoo,
) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureBar(
    ctx context.Context,
    obj *v1alpha1.Foo,
    desiredFoo DesiredFoo,
) flow.Outcome
```

---

## Receivers (MUST)

- EnsureReconcileHelpers **SHOULD** be plain functions when they do not need any data from `Reconciler`.
- If an EnsureReconcileHelper needs data from `Reconciler`, it **MUST** be a method on `Reconciler`.

---

## I/O boundaries (MUST)

EnsureReconcileHelpers **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering decisions;
- creating/updating/deleting Kubernetes objects in the API server in any form.

EnsureReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads) (except setting `metav1.Condition.LastTransitionTime`, typically indirectly via `obju.SetStatusCondition`);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

EnsureReconcileHelpers **MAY** request optimistic locking by encoding it in the returned `flow.Outcome`, but they **MUST NOT** perform the save operation themselves.

> Rationale: ensure helpers should be deterministic and unit-testable; they describe intended changes (and save-mode requirements), while the actual persistence belongs to Reconcile methods.

---

## Determinism contract (MUST)

An EnsureReconcileHelper **MUST** be deterministic given its explicit inputs and allowed in-place mutations.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular:
- EnsureReconcileHelpers **MAY** use extracted computation/caching components owned by the reconciler (e.g. “world view” / “planner” / “topology scorer”, unique ID pools, caches), as described in `controller-file-structure.mdc` (“Additional components”), as long as they do not violate the I/O boundaries above.
  - Note: cache population or allocating an ID from a pool is a side effect and an additional source of state; therefore, the helper is deterministic only relative to that state. For the same explicit inputs and the same state of these components, the result **MUST** be the same.
- Returned `flow.Outcome` flags (changed / optimisticLock / error) **MUST** be stable for the same inputs and object state.

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract (MUST)

`ensure*` / `Ensure*` **MUST** treat all inputs except the intended in-place mutation on `obj` as read-only:

- it **MUST NOT** mutate any input other than `obj` (including computed dependencies passed after `obj`, templates, shared defaults, global variables);
- it **MUST** mutate only the intended patch domain on `obj` (main resource **or** status subresource), treating the other domain as read-only;
- it **MUST NOT** perform in-place modifications through aliases to non-`obj` data.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation (MUST)

- `ensure*` / `Ensure*` **MUST** mutate `obj` in-place for **exactly one** patch domain:
  - main resource (**metadata + spec + non-status fields**), **or**
  - status subresource (`.status`).
- An EnsureReconcileHelper **MUST NOT** mutate both domains in the same function.
- If you need “ensure” logic for both domains, you **MUST** split it into **two** ensure helpers and call them separately from Reconcile methods (with separate patch requests).

✅ Separate ensure helpers (GOOD)
```go
func ensureMainFoo(obj *v1alpha1.Foo) flow.Outcome
func ensureStatusFoo(obj *v1alpha1.Foo) flow.Outcome
```

❌ Mixed ensure (BAD)
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    // mutates spec/metadata AND status in one helper
    return flow.Continue()
}
```

## Composition (MUST)

- An EnsureReconcileHelper **MAY** implement multiple related “ensure” steps in one pass **within a single patch domain**.
  - If these steps represent one conceptual invariant set, they **SHOULD** remain in one ensure helper.
  - If steps are distinguishable and reused independently, they **SHOULD** be extracted into smaller ensure helpers.
- An EnsureReconcileHelper **MAY** call other ensure helpers (compose “sub-ensures”).
- An EnsureReconcileHelper **MAY** depend on outputs of previous compute helpers:
  - the dependency **MUST** be explicit in the signature as additional args **after `obj`**.
- If an EnsureReconcileHelper composes multiple sub-ensures, it **MUST** combine their results deterministically:
  - “changed” information **MUST** be preserved (no dropping);
  - optimistic-locking requirement **MUST** be preserved;
  - errors **MUST** be preserved (no dropping), using a deterministic aggregation strategy (e.g., `flow.Merge(...)`).

## Flow phases and `flow.Outcome` (MUST)

- If an EnsureReconcileHelper has complex logic, produces many logs, or calls other helpers, it **SHOULD** create a `reconcile/flow` phase to keep execution/logging structured.
  - If it creates a phase (or writes logs), it **MUST** accept `ctx context.Context` (see `controller-reconcile-helper.mdc`).
- EnsureReconcileHelpers **MUST** return `flow.Outcome` using helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.
  - Use outcome reporting (e.g., “changed” / optimistic-lock intent) via the `flow.Outcome` API.

---

## Error handling (SHOULD)

- See the common error handling rules in `controller-reconcile-helper.mdc`.
  - Errors should typically be returned via `flow.Fail(err)`.

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API I/O (directly or indirectly):
```go
func ensureFoo(ctx context.Context, obj *v1alpha1.Foo) flow.Outcome {
    // forbidden: I/O in ensure
    var cm corev1.ConfigMap
    if err := r.client.Get(ctx, nn, &cm); err != nil {
        return flow.Fail(err)
    }
    return flow.Continue()
}
```

❌ Executing patches / updates / deletes (or hiding them behind helpers):
```go
func ensureFoo(ctx context.Context, obj *v1alpha1.Foo) flow.Outcome {
    // forbidden: patch execution belongs to Reconcile methods / PatchReconcileHelpers
    base := obj.DeepCopy() // also forbidden: DeepCopy in ensure
    obj.Spec.Replicas = 3
    _ = r.client.Patch(ctx, obj, client.MergeFrom(base))
    return flow.Continue().ReportChanged()
}
```

❌ Calling `DeepCopy` inside ensure helpers:
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    return flow.Continue()
}
```

❌ Mutating both patch domains (main + status) in one ensure helper:
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    obj.Spec.Replicas = 3            // main domain
    obj.Status.Phase = "Reconciling" // status domain
    // forbidden: ensure must touch exactly one patch domain
    return flow.Continue().ReportChanged()
}
```

❌ Returning “changed” inconsistently (mutated object but outcome does not report it):
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    obj.Spec.Replicas = 3
    // forbidden: mutation happened, but outcome does not report change
    return flow.Continue()
}
```

❌ Reporting “changed” without actually changing the object:
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    // forbidden: reports change but did not mutate anything
    return flow.Continue().ReportChanged()
}
```

❌ Requesting optimistic locking “sometimes” without determinism (same inputs -> different outcome):
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    if rand.Int()%2 == 0 { // forbidden: nondeterministic
        return flow.Continue().ReportOptimisticLock().ReportChanged()
    }
    return flow.Continue().ReportChanged()
}
```

❌ Hidden I/O / nondeterminism (time/random/env/network):
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    _ = time.Now()        // forbidden (except condition timestamps via obju)
    _ = rand.Int()        // forbidden
    _ = os.Getenv("FLAG") // forbidden
    return flow.Continue()
}
```

❌ Depending on map iteration order when building ordered slices (patch churn):
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    out := make([]string, 0, len(obj.Spec.Flags))
    for k := range obj.Spec.Flags { // map iteration order is random
        out = append(out, k)
    }
    // missing sort => nondeterministic object state
    obj.Spec.FlagKeys = out
    return flow.Continue().ReportChanged()
}
```

❌ Mutating shared templates/defaults through aliasing:
```go
func ensureFoo(obj *v1alpha1.Foo, template *v1alpha1.Foo) flow.Outcome {
    // forbidden: template labels map is shared; mutating it mutates the template
    labels := template.GetLabels()
    labels["owned"] = "true"
    obj.SetLabels(labels)
    return flow.Continue().ReportChanged()
}
```

❌ Manual metadata/conditions manipulation when `objutilv1` (`obju`) must be used:
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    // forbidden in this codebase: do not open-code label/finalizer/condition edits
    if obj.Labels == nil {
        obj.Labels = map[string]string{}
    }
    obj.Labels["a"] = "b"
    return flow.Continue().ReportChanged()
}
```
