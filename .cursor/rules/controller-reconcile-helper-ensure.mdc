---
description: Controller reconciliation helpers — EnsureReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# EnsureReconcileHelper

This document defines naming and contracts for **EnsureReconcileHelper** functions/methods.

Common terminology and rules for any ReconcileHelper live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

TODO: define TL;DR for EnsureReconcileHelper.

---

## Definition (MUST)

An **EnsureReconcileHelper** (“ensure helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- performs in-place “make it more correct” mutations on the object for **exactly one patch domain** (main resource **or** status subresource), and
- returns a `flow.Outcome` that reports whether it changed the object, whether optimistic locking is required for the save operation (if any), and whether an error occurred.

Typical ensure helpers implement step-by-step in-place reconciliation and return `flow.Outcome` (e.g., via `flow.Continue().ReportChanged()`, `flow.ContinueErr(...)`, `flow.Done()`, `flow.Fail(err)`, etc.) to drive patching decisions in Reconcile methods.

---

## Naming (MUST)

- An **EnsureReconcileHelper** name **MUST** start with `ensure` / `Ensure`.
- EnsureReconcileHelpers **MUST** be domain-explicit in the name when ambiguity is possible:
  - `ensureMain*` / `EnsureMain*` (main resource)
  - `ensureStatus*` / `EnsureStatus*` (status subresource)

Guidance (SHOULD):
- Name the invariant or property being ensured:
  - `ensureFinalizer(...)`
  - `ensureOwnerRefs(...)`
  - `ensureDesiredLabels(...)`
  - `ensureStatusConditions(...)`
- Avoid “orchestrator-sounding” names (`ensureAll`, `ensureEverything`, `ensureAndPatch`) — ensure helpers do not execute I/O; they only mutate and return `flow.Outcome`.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and flow semantics.

### Simple ensure (SHOULD)
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureFoo(obj *v1alpha1.Foo) flow.Outcome
```

### Ensure with logging / phases (SHOULD)
```go
func ensureFoo(
    ctx context.Context,
    obj *v1alpha1.Foo,
) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureFoo(
    ctx context.Context,
    obj *v1alpha1.Foo,
) flow.Outcome
```

### Dependent ensure (MUST)
Dependencies **MUST** be explicit and come **after `obj`**:
```go
func ensureBar(
    ctx context.Context,
    obj *v1alpha1.Foo,
    desiredFoo DesiredFoo,
) flow.Outcome
```

Or, if an ensure helper needs data from `Reconciler`:
```go
func (r *Reconciler) ensureBar(
    ctx context.Context,
    obj *v1alpha1.Foo,
    desiredFoo DesiredFoo,
) flow.Outcome
```

---

## Receivers (MUST)

- EnsureReconcileHelpers **SHOULD** be plain functions when they do not need any data from `Reconciler`.
- If an EnsureReconcileHelper needs data from `Reconciler`, it **MUST** be a method on `Reconciler`.

---

## I/O boundaries (MUST)

EnsureReconcileHelpers **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering decisions;
- creating/updating/deleting Kubernetes objects in the API server in any form.

EnsureReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads) (except setting `metav1.Condition.LastTransitionTime`, typically indirectly via `obju.SetStatusCondition`);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

EnsureReconcileHelpers **MAY** request optimistic locking by encoding it in the returned `flow.Outcome`, but they **MUST NOT** perform the save operation themselves.

> Rationale: ensure helpers should be deterministic and unit-testable; they describe intended changes (and save-mode requirements), while the actual persistence belongs to Reconcile methods.

---

## Determinism contract (MUST)

An EnsureReconcileHelper **MUST** be deterministic given its explicit inputs and allowed in-place mutations.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular:
- EnsureReconcileHelpers **MAY** use extracted computation/caching components owned by the reconciler (e.g. “world view” / “planner” / “topology scorer”, unique ID pools, caches), as described in `controller-file-structure.mdc` (“Additional components”), as long as they do not violate the I/O boundaries above.
  - Note: cache population or allocating an ID from a pool is a side effect and an additional source of state; therefore, the helper is deterministic only relative to that state. For the same explicit inputs and the same state of these components, the result **MUST** be the same.
- Returned `flow.Outcome` flags (changed / optimisticLock / error) **MUST** be stable for the same inputs and object state.

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract (MUST)

`ensure*` / `Ensure*` **MUST** treat all inputs except the intended in-place mutation on `obj` as read-only:

- it **MUST NOT** mutate any input other than `obj` (including computed dependencies passed after `obj`, templates, shared defaults, global variables);
- it **MUST** mutate only the intended patch domain on `obj` (main resource **or** status subresource), treating the other domain as read-only;
- it **MUST NOT** perform in-place modifications through aliases to non-`obj` data.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation (MUST)

- `ensure*` / `Ensure*` **MUST** mutate `obj` in-place for **exactly one** patch domain:
  - main resource (**metadata + spec + non-status fields**), **or**
  - status subresource (`.status`).
- An EnsureReconcileHelper **MUST NOT** mutate both domains in the same function.
- If you need “ensure” logic for both domains, you **MUST** split it into **two** ensure helpers and call them separately from Reconcile methods (with separate patch requests).

✅ Separate ensure helpers (GOOD)
```go
func ensureMainFoo(obj *v1alpha1.Foo) flow.Outcome
func ensureStatusFoo(obj *v1alpha1.Foo) flow.Outcome
```

❌ Mixed ensure (BAD)
```go
func ensureFoo(obj *v1alpha1.Foo) flow.Outcome {
    // mutates spec/metadata AND status in one helper
    return flow.Continue()
}
```

## Composition (MUST)

- An EnsureReconcileHelper **MAY** implement multiple related “ensure” steps in one pass **within a single patch domain**.
  - If these steps represent one conceptual invariant set, they **SHOULD** remain in one ensure helper.
  - If steps are distinguishable and reused independently, they **SHOULD** be extracted into smaller ensure helpers.
- An EnsureReconcileHelper **MAY** call other ensure helpers (compose “sub-ensures”).
- An EnsureReconcileHelper **MAY** depend on outputs of previous compute helpers:
  - the dependency **MUST** be explicit in the signature as additional args **after `obj`**.
- If an EnsureReconcileHelper composes multiple sub-ensures, it **MUST** combine their results deterministically:
  - “changed” information **MUST** be preserved (no dropping);
  - optimistic-locking requirement **MUST** be preserved;
  - errors **MUST** be preserved (no dropping), using a deterministic aggregation strategy (e.g., `flow.Merge(...)`).

## Flow phases and `flow.Outcome` (MUST)

- If an EnsureReconcileHelper has complex logic, produces many logs, or calls other helpers, it **SHOULD** create a `reconcile/flow` phase to keep execution/logging structured.
  - If it creates a phase (or writes logs), it **MUST** accept `ctx context.Context` (see `controller-reconcile-helper.mdc`).
- EnsureReconcileHelpers **MUST** return `flow.Outcome` using helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.
  - Use outcome reporting (e.g., “changed” / optimistic-lock intent) via the `flow.Outcome` API.

---

## Error handling (SHOULD)

- See the common error handling rules in `controller-reconcile-helper.mdc`.
  - Errors should typically be returned via `flow.Fail(err)`.

---

## ALLOW / DENY cheat sheet

TODO: define ALLOW / DENY cheat sheet for EnsureReconcileHelper.

---

## Common anti-patterns (MUST NOT)

TODO: define common anti-patterns for EnsureReconcileHelper.
