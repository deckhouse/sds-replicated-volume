---
description: Controller reconciliation helpers — common rules
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# ReconcileHelper functions/methods

This document defines naming and contracts for **ReconcileHelper** functions/methods.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

- **Reconcile methods** (`Reconcile*` / `reconcile*`) own reconciliation orchestration and I/O sequencing; **ReconcileHelpers** are category-named helpers used by them.
- All ReconcileHelpers follow strict **naming-by-category** (`compute*`, `is*UpToDate*`, `apply*`, `ensure*`, `create*`, `delete*`, `patch*`) to make intent and allowed behavior reviewable.
- Every ReconcileHelper has explicit dependencies: if it takes `ctx`, it is first; if it operates on a Kubernetes object, `obj` is the first arg after `ctx`; all other inputs come **after `obj`**.
- ReconcileHelpers are **deterministic**: never rely on map iteration order; sort when order matters; avoid “equivalent but different” outputs/states that cause patch churn.
- ReconcileHelpers treat inputs as **read-only** except for the explicitly allowed mutation target(s); never mutate through map/slice aliasing — **clone before editing**.
- I/O is **explicitly bounded by category**:
  - **Compute / IsUpToDate / Apply / Ensure**: strictly **non-I/O**.
  - **Create / Delete / Patch**: allowed I/O, but **exactly one API write** per helper (`Create` / `Delete` / `Patch` or `Status().Patch`).

---

## ALLOW / DENY cheat sheet

**ALLOW (MAY):**
- Use **Reconcile methods** (`reconcile*` / `Reconcile*`) to orchestrate reconciliation steps, sequencing, retries, and multi-step policies.
- Implement helpers that match one of the **ReconcileHelper categories** and follow that category’s I/O and mutation rules:
  - `compute*` / `Compute*`: pure computation.
  - `is*UpToDate*` / `Is*UpToDate*`: tiny pure boolean checks.
  - `apply*` / `Apply*`: mechanical in-memory writes to `obj` (one patch domain).
  - `ensure*` / `Ensure*`: in-memory “make it more correct” mutations to `obj` (one patch domain) + `flow.Outcome`.
  - `create<Kind>` / `Create<Kind>`: exactly one `Create(...)` call for one object.
  - `delete<Kind>` / `Delete<Kind>`: exactly one `Delete(...)` call for one object.
  - `patch<Kind>` / `Patch<Kind>`: exactly one patch call for one domain (`Patch` or `Status().Patch`) for one object.
- Keep dependencies **explicit** in signatures:
  - `ctx` first (only when phases/logging are allowed by the category),
  - then `obj *<Kind>` as the first arg after `ctx`,
  - then everything else **after `obj`**.
- Maintain determinism:
  - sort when order matters,
  - stabilize outputs derived from maps/sets,
  - avoid “equivalent but different” states that cause patch churn.
- Treat inputs as read-only unless the category explicitly allows mutation:
  - clone maps/slices before editing,
  - avoid sharing map/slice backing storage between `desired`/templates and `obj`,
  - treat patch bases as read-only diff references.
- Use `flow.Outcome` only in categories that allow it (notably `ensure*` and optionally I/O helpers like `create*`/`delete*`/`patch*` when the codebase chooses to encode outcomes there).

**DENY (MUST NOT):**
- **Category violations** (the most important rule):
  - Any Kubernetes API I/O from non-I/O categories (`compute*`, `is*UpToDate*`, `apply*`, `ensure*`).
  - More than **one** API write in a single I/O helper (`create*`, `delete*`, `patch*`).
  - Mixing patch domains in helpers that must be single-domain (notably `apply*`, `ensure*`, `patch*`, `is*UpToDate*`).
- Hidden / implicit dependencies:
  - reading `time.Now()`, random, env/filesystem, or extra network calls where not explicitly allowed by the category;
  - using global variables/singletons instead of explicit arguments (unless the category doc explicitly allows a reconciler-owned deterministic component).
- Input mutation outside allowed targets:
  - mutating “read-only” inputs (including `desired`, templates, computed deps),
  - mutating through aliasing (maps/slices) instead of cloning,
  - mutating patch base objects (`base`) used for diffs.
- Unstable behavior:
  - relying on map iteration order for ordered outputs,
  - producing nondeterministic ordering in fields that affect patch diffs.
- Ambiguous / non-reviewable naming:
  - helpers that don’t match a category prefix/pattern,
  - inventing new kind abbreviations that aren’t established in the codebase.
- Putting orchestration into helpers:
  - retries/loops that cause multiple API calls inside one helper,
  - “patch main then status” inside a single helper,
  - “create then patch status” hidden inside `create*`, etc.

---

## Terminology (MUST)

- **Reconcile methods**: the controller-runtime `Reconcile(...)` method and any other function/method whose name matches `reconcile*` / `Reconcile*` (see `controller-file-structure.mdc`).
- **ReconcileHelper functions/methods**: any helper function/method used by **Reconcile methods**, implemented in `reconciler.go`, whose name matches one of the **ReconcileHelper categories** below.
  - When referring to *any* helper from these categories, use **ReconcileHelper**.
  - When referring to a *specific kind* of helper, use the corresponding category name below.

### ReconcileHelper categories (MUST)

These categories are naming categories/patterns (see also `controller-file-structure.mdc`):

- **ComputeReconcileHelper**: `compute*` / `Compute*` (see `controller-reconcile-helper-compute.mdc`).
- **IsUpToDateReconcileHelper**: `is*UpToDate*` / `Is*UpToDate*` (starts with `is`/`Is` and contains `UpToDate`) (see `controller-reconcile-helper-is-up-to-date.mdc`).
- **ApplyReconcileHelper**: `apply*` / `Apply*` (see `controller-reconcile-helper-apply.mdc`).
- **EnsureReconcileHelper**: `ensure*` / `Ensure*` (see `controller-reconcile-helper-ensure.mdc`).
- **CreateReconcileHelper**: `create*` / `Create*` (see `controller-reconcile-helper-create.mdc`).
- **DeleteReconcileHelper**: `delete*` / `Delete*` (see `controller-reconcile-helper-delete.mdc`).
- **PatchReconcileHelper**: `patch*` / `Patch*` (see `controller-reconcile-helper-patch.mdc`).

---

## Scope (MUST)

This document defines **common** conventions for all ReconcileHelper categories.

Category-specific conventions are defined in dedicated documents referenced in **“ReconcileHelper categories (MUST)”** above.

---

## Any ReconcileHelper

### Signatures (MUST)

- If a ReconcileHelper creates a reconcile/flow phase or writes logs, it **MUST** accept `ctx context.Context`.
- A function operating on a Kubernetes object **MUST** take a pointer to the root object as:
  - the **first argument** if the function does not accept `ctx`;
  - the **first argument after `ctx`** if the function accepts `ctx`.
  (root object = the full API object (`*<Kind>`), not `Spec`/`Status` or other sub-structs)
- Additional inputs (computed flags, outputs of previous compute steps) **MUST** appear **after `obj`** to keep dependencies explicit.
- If a ReconcileHelper returns `flow.Outcome`, it **MUST** be the **first return value**.
  - It **SHOULD** be the only return value for convenience, unless additional return values are clearly justified.

### Visibility and receivers (SHOULD)

- ReconcileHelpers **SHOULD** be unexported (private) by default. Export a ReconcileHelper only with an explicit, documented reason.
- ReconcileHelpers **SHOULD** be plain functions when they do not need any data from `Reconciler`.
  - If a ReconcileHelper needs data from `Reconciler`, it **SHOULD** be a method on `Reconciler`.

### Naming (MUST)

- If a ReconcileHelper name includes a Kubernetes object kind (e.g. `create<Kind>`, `delete<Kind>`, `patch<Kind>`), `<Kind>` **MAY** be either:
  - a short, codebase-established name (preferred in examples), or
  - the full kind name.
- If a short kind name is used, it **MUST** be an established name in this codebase (do not invent new abbreviations ad-hoc).
  - Examples: `createSKN(...)` (or `createSomeKindName(...)`), `patchSKN(...)` (or `patchSomeKindName(...)`).

### Determinism contract (MUST)

Any ReconcileHelper **MUST** be deterministic given its explicit inputs and allowed mutations / I/O boundaries.

In particular:
- Never rely on map iteration order: if output order matters, **MUST** sort it.
- If you build ordered slices from maps/sets (finalizers/ownerRefs/conditions/etc.), **MUST** make ordering stable (`slices.Sort`, sort by key, etc.).
- Avoid producing “equivalent but different” object states or intermediate representations across runs (e.g., writing the same elements in different order).

> Practical reason: nondeterminism creates patch churn and flaky tests.

### Read-only contract (MUST)

Any ReconcileHelper **MUST** treat all inputs except explicitly allowed mutation targets as read-only.

In particular:
- It **MUST NOT** mutate inputs other than the allowed mutation target(s).
- It **MUST NOT** perform in-place modifications through aliases to read-only inputs.

**Important Go aliasing rule (MUST):**
- `map` / `[]T` values are reference-like. If you copy them from a read-only input and then mutate them, you may be mutating the original input through aliasing.
- Therefore, if you need to modify a map/slice derived from a read-only input, you **MUST** clone/copy it first.

Examples (illustrative):

✅ GOOD: clone before normalizing/editing (derived from `obj`)
```go
labels := maps.Clone(obj.GetLabels())
labels["some/ephemeral"] = "" // edit on a clone
```

❌ BAD: mutates input through alias
```go
labels := obj.GetLabels()
labels["some/ephemeral"] = "" // mutates obj
```

✅ GOOD: clone slice before editing
```go
in := obj.Spec.SomeSlice
out := slices.Clone(in) // or append([]T(nil), in...)
out = append(out, "new")
```

✅ GOOD: clone desired map before setting on `obj`
```go
labels := maps.Clone(desired.Labels)
obj.SetLabels(labels)
```

❌ BAD: shares map with desired (and future edits may mutate desired)
```go
obj.SetLabels(desired.Labels) // aliasing
```

Note: the same cloning rule applies to any other read-only inputs (e.g., shared templates/dependencies or patch bases).

### Error handling (SHOULD)

- Prefer returning domain-specific errors with enough context to debug:
  - include object key when relevant (`namespace/name`), and
  - include the problematic field or constraint.
- Do **not** log and also return an error for the same condition unless the surrounding reconcile style explicitly requires it (avoid duplicate logs).

