---
description: Controller reconciliation helpers — common rules
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# ReconcileHelper functions/methods

This document defines naming and contracts for **ReconcileHelper** functions/methods.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **Reconcile methods** (`Reconcile*` / `reconcile*`) own reconciliation orchestration and I/O sequencing; **ReconcileHelpers** are category-named helpers used by them.
- All ReconcileHelpers follow strict **naming-by-category** (`compute*`, `is*UpToDate*`, `apply*`, `ensure*`, `create*`, `delete*`, `patch*`) to make intent and allowed behavior reviewable.
- Every ReconcileHelper has explicit dependencies: if it takes `ctx`, it is first; if it operates on a Kubernetes object, `obj` is the first arg after `ctx`; all other inputs come **after `obj`**.
- ReconcileHelpers are **deterministic**: never rely on map iteration order; sort when order matters; avoid “equivalent but different” outputs/states that cause patch churn.
- ReconcileHelpers treat inputs as **read-only** except for the explicitly allowed mutation target(s); never mutate through map/slice aliasing — **clone before editing**.
- I/O is **explicitly bounded by category**:
  - **Compute / IsUpToDate / Apply / Ensure**: strictly **non-I/O**.
  - **Create / Delete / Patch**: allowed I/O, but **exactly one API write** per helper (`Create` / `Delete` / `Patch` or `Status().Patch`).

---

## Terminology

- **Reconcile methods**: the controller-runtime `Reconcile(...)` method and any other function/method whose name matches `reconcile*` / `Reconcile*` (see `controller-file-structure.mdc`).
- **ReconcileHelper functions/methods**: any helper function/method used by **Reconcile methods**, implemented in `reconciler.go`, whose name matches one of the **ReconcileHelper categories** below.
  - When referring to *any* helper from these categories, use **ReconcileHelper**.
  - When referring to a *specific kind* of helper, use the corresponding category name below.

### ReconcileHelper categories

These categories are naming categories/patterns (see also `controller-file-structure.mdc`):

- **ComputeReconcileHelper**: `compute*` / `Compute*` (see `controller-reconcile-helper-compute.mdc`).
- **IsUpToDateReconcileHelper**: `is*UpToDate*` / `Is*UpToDate*` (starts with `is`/`Is` and contains `UpToDate`) (see `controller-reconcile-helper-is-up-to-date.mdc`).
- **ApplyReconcileHelper**: `apply*` / `Apply*` (see `controller-reconcile-helper-apply.mdc`).
- **EnsureReconcileHelper**: `ensure*` / `Ensure*` (see `controller-reconcile-helper-ensure.mdc`).
- **CreateReconcileHelper**: `create*` / `Create*` (see `controller-reconcile-helper-create.mdc`).
- **DeleteReconcileHelper**: `delete*` / `Delete*` (see `controller-reconcile-helper-delete.mdc`).
- **PatchReconcileHelper**: `patch*` / `Patch*` (see `controller-reconcile-helper-patch.mdc`).

---

## Scope

This document defines **common** conventions for all ReconcileHelper categories.

Category-specific conventions are defined in dedicated documents referenced in **“ReconcileHelper categories (MUST)”** above.

---

## Any ReconcileHelper

### Signatures (MUST)

- If a ReconcileHelper creates a reconcile/flow phase or writes logs, it **MUST** accept `ctx context.Context`.
- A function operating on a Kubernetes object **MUST** take a pointer to the root object as:
  - the **first argument** if the function does not accept `ctx`;
  - the **first argument after `ctx`** if the function accepts `ctx`.
  (root object = the full API object (`*<Kind>`), not `Spec`/`Status` or other sub-structs)
- Additional inputs (computed flags, outputs of previous compute steps) **MUST** appear **after `obj`** to keep dependencies explicit.
- If a ReconcileHelper returns `flow.Outcome`, it **MUST** be the **first return value**.
  - It **SHOULD** be the only return value for convenience, unless additional return values are clearly justified.

### Flow **phases** and **Outcome**

- **Phase** usage (`flow.BeginPhase` / `flow.EndPhase`) is **strictly limited**:
  - **Large `ensure*`**: **MUST** create a **phase**.
    - “Large” includes: many sub-steps, loops over items, and/or non-trivial error handling.
  - **Large `compute*`**: **MAY** create a **phase** **only when it improves structure or diagnostics**.
  - **All other Helper categories** (`apply*`, `is*UpToDate*`, `create*`, `delete*`, `patch*`) **MUST NOT** create **phases**.
- If a helper uses **phases**, it **MUST** follow `internal/reconciliation/flow` rules (one **phase** per function; **phase** on first line; no **phases** inside loops).

### Visibility and receivers (SHOULD)

- ReconcileHelpers **SHOULD** be unexported (private) by default. Export a ReconcileHelper only with an explicit, documented reason.
- ReconcileHelpers **SHOULD** be plain functions when they do not need any data from `Reconciler`.
  - If a ReconcileHelper needs data from `Reconciler`, it **SHOULD** be a method on `Reconciler`.

### Naming (MUST)

- If a ReconcileHelper name includes a Kubernetes object kind (e.g. `create<Kind>`, `delete<Kind>`, `patch<Kind>`), `<Kind>` **MAY** be either:
  - a short, codebase-established name (preferred in examples), or
  - the full kind name.
- If a short kind name is used, it **MUST** be an established name in this codebase (do not invent new abbreviations ad-hoc).
  - Examples: `createSKN(...)` (or `createSomeKindName(...)`), `patchSKN(...)` (or `patchSomeKindName(...)`).

### Determinism contract (MUST)

Any ReconcileHelper **MUST** be deterministic given its explicit inputs and allowed mutations / I/O boundaries.

In particular:
- Never rely on map iteration order: if output order matters, **MUST** sort it.
- If you build ordered slices from maps/sets (finalizers/ownerRefs/conditions/etc.), **MUST** make ordering stable (`slices.Sort`, sort by key, etc.).
- Avoid producing “equivalent but different” object states or intermediate representations across runs (e.g., writing the same elements in different order).

> Practical reason: nondeterminism creates patch churn and flaky tests.

### Read-only contract (MUST)

Any ReconcileHelper **MUST** treat all inputs except explicitly allowed mutation targets as read-only.

In particular:
- It **MUST NOT** mutate inputs other than the allowed mutation target(s).
- It **MUST NOT** perform in-place modifications through aliases to read-only inputs.

**Important Go aliasing rule (MUST):**
- `map` / `[]T` values are reference-like. If you copy them from a read-only input and then mutate them, you may be mutating the original input through aliasing.
- Therefore, if you need to modify a map/slice derived from a read-only input, you **MUST** clone/copy it first.

Examples (illustrative):

✅ GOOD: clone before normalizing/editing (derived from `obj`)
```go
labels := maps.Clone(obj.GetLabels())
labels["some/ephemeral"] = "" // edit on a clone
```

❌ BAD: mutates input through alias
```go
labels := obj.GetLabels()
labels["some/ephemeral"] = "" // mutates obj
```

✅ GOOD: clone slice before editing
```go
in := obj.Spec.SomeSlice
out := slices.Clone(in) // or append([]T(nil), in...)
out = append(out, "new")
```

✅ GOOD: clone desired map before setting on `obj`
```go
labels := maps.Clone(desired.Labels)
obj.SetLabels(labels)
```

❌ BAD: shares map with desired (and future edits may mutate desired)
```go
obj.SetLabels(desired.Labels) // aliasing
```

Note: the same cloning rule applies to any other read-only inputs (e.g., shared templates/dependencies or patch bases).

### Error handling

- **ReconcileHelpers** **SHOULD** generally return errors as-is. Do not enrich errors “for the outside world” in helpers.
- **Hard ban (MUST NOT)**: a **ReconcileHelper** error **MUST NOT** include **object identity** (e.g. `namespace/name`, UID, object key).
  - Rationale: **object identity** and action-level context belong to the calling **Reconcile method**, which owns orchestration and **phases**.
- If a **ReconcileHelper** creates its own local validation error, it **MAY** include the **problematic field/constraint** (purely local, non-identity) to keep the error actionable.
- If additional context is needed to disambiguate multiple *different* error sources within the same **Reconcile method**, this is allowed only where the category doc explicitly permits it (notably `compute*` / `ensure*`), and the added context **MUST** remain local and non-identifying.
- Do **not** log and also return an error for the same condition unless the surrounding reconcile style explicitly requires it (avoid duplicate logs).

---

## When to create helpers (SHOULD/MUST NOT)

This section is **not** about what helpers are *allowed* to do (see the category docs). This section is about **when extracting a helper is worth it** vs when it is unnecessary indirection.

### General guidance

- Prefer **locality**: keep logic close to its only call site unless extraction clearly improves reuse or readability.
- Prefer **category purity** over “nice structure”: do not create helpers that *almost* fit a category. If it needs orchestration or mixes domains, keep it in a Reconcile method (or split into multiple helpers in correct categories).
- Extract when it helps you enforce **determinism** or **domain separation** (main vs status), especially when doing it inline would be error-prone.

### CreateReconcileHelper (`create*`) / PatchReconcileHelper (`patch*`) / DeleteReconcileHelper (`delete*`) (I/O helpers)

- **SHOULD** create these helpers **only when they have 2+ call sites** (within the same controller package).
- **SHOULD NOT** create them “for symmetry” if the helper would only hide a one-off, standard I/O action (even when that action is usually written as a small boilerplate block in Reconcile methods).

### ApplyReconcileHelper (`apply*`) / IsUpToDateReconcileHelper (`is*UpToDate*`) (small pure helpers)

- **SHOULD** create these helpers only when the logic cannot be expressed as **one obvious action** at the call site.
  - Examples of “one obvious action” (inline instead of helper): a single `obju.*` call; a single simple assignment; a single `meta` / `metav1` helper call.
- **SHOULD** create these helpers when:
  - the call site would otherwise contain multiple coordinated field writes/comparisons for the same patch domain;
  - the logic requires deterministic normalization (sorting/canonicalization) that you want to keep consistent between “compute“, “check” and “apply”.

### ComputeReconcileHelper (`compute*`) / EnsureReconcileHelper (`ensure*`) (core of reconciliation logic)

- If reconciliation needs to derive a target/desired state (or a derived “actual” view), there **SHOULD** be at least one explicit step that performs this work as either:
  - a ComputeReconcileHelper (`computeDesired*` / `computeActual*`), or
  - an EnsureReconcileHelper (`ensure*`) that both derives and applies corrections in-place.
  The intent is to keep Reconcile methods focused on orchestration and to make “where decisions live” reviewable.

#### Splitting / nesting guidelines

- **SHOULD NOT** split trivial logic into ComputeReconcileHelper (`compute*`) + EnsureReconcileHelper (`ensure*`) just to “follow patterns”. If one small helper can do it clearly (and within category rules), keep it in one place.
- **MAY** create an EnsureReconcileHelper (`ensure*`) that is only an orchestrator for ComputeReconcileHelper (`compute*`) → IsUpToDateReconcileHelper (`is*UpToDate*`) → ApplyReconcileHelper (`apply*`) **only** when it significantly improves readability at the call site and does not hide orchestration decisions (ordering/retries/patch policy) that must remain explicit in a Reconcile method.
  - In general, the purpose of EnsureReconcileHelper (`ensure*`) is to perform in-place, step-by-step corrections on `obj` (for a single patch domain), not to wrap a desired-driven pipeline.
- If an EnsureReconcileHelper (`ensure*`) is small and readable, keep it monolithic:
  - **SHOULD NOT** extract a separate ComputeReconcileHelper (`compute*`) just to compute a couple of booleans or a tiny struct.
- If an EnsureReconcileHelper (`ensure*`) becomes complex:
  - **MAY** split it into multiple sub-EnsureReconcileHelper (`ensure*`) helpers (same domain; explicit dependencies after `obj`).
  - **MAY** extract sub-ComputeReconcileHelper (`compute*`) helpers for non-trivial derived values used by ensure, keeping them pure and deterministic.
- If a ComputeReconcileHelper (`compute*`) becomes complex:
  - **MAY** split it into smaller ComputeReconcileHelper (`compute*`) helpers (pure composition) with explicit data flow via parameters/return values.
  - **SHOULD** keep each compute focused on a single artifact (desired labels, desired spec fragment, desired status fragment, etc.), rather than a “compute everything” blob.
