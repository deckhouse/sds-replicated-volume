---
description: Controller entrypoint rules for controller.go (wiring-only, controller-runtime builder, runnables, predicates)
globs:
  - "images/controller/internal/controllers/**/controller.go"
alwaysApply: true
---

- TL;DR:
  - **`controller.go`** = **Wiring-only** **Entrypoint**.
  - **Entrypoint** = `BuildController(mgr manager.Manager) error`.
  - **builder chain** = single fluent chain, ends with `.Complete(rec)`.
  - **predicates** = **mechanical** change detection (no **I/O**, no **domain/business** decisions).
  - All **Reconciliation business logic** = **`reconciler.go`**.

- **`controller.go`** purpose (**MUST**):
  - **`controller.go`** is the **Wiring-only** **Entrypoint** of a **controller package**.
  - It owns controller-runtime **builder chain** configuration, **watch** registration, and reconciler construction.
  - It **MUST NOT** contain **Reconciliation business logic** (that belongs to **`reconciler.go`**).

- ALLOW (in **`controller.go`**):
  - controller-runtime builder wiring:
    - `.ControllerManagedBy(mgr).Named(...)`
    - `.For(...)`, `.Owns(...)`, `.Watches(...)`
    - `.WithOptions(...)`, `.Complete(...)`
  - **predicates**/**filters** (lightweight, **mechanical** change detection).
  - **Manager-owned dependencies** (wiring-only) from the **manager**:
    - `mgr.GetClient()`, `mgr.GetScheme()`, `mgr.GetCache()`, `mgr.GetEventRecorderFor(...)`
  - registering **runnables**/**sources** on the **manager** (wiring-only), e.g. `mgr.Add(...)`, indexes, **sources**.

- DENY (in **`controller.go`**):
  - any functions that **compute/ensure/apply/reconcile** domain logic (must live in `reconciler.go`).
  - reading/modifying `.Spec` / `.Status`:
    - allowed only inside **predicates** and only for **field comparisons** (no multi-step logic; no mutations).
    - direct `.Status.Conditions` access is forbidden in predicates — use `obju` only.
  - any multi-step decisions (state machines, placement, scheduling, condition computation).
  - any **Kubernetes API I/O** beyond **manager** wiring (`Get/List/Create/Update/Patch/Delete`).

- **`controller.go`** layout (**MUST**):
  - `const <ControllerName> = "<name>"` (stable **controller name**).
  - **Entrypoint**: `BuildController(mgr manager.Manager) error`.
  - **predicates**/**filters** **MUST** be present to reduce **reconcile loop** noise.

- What belongs in `BuildController` (**MUST**):
  - Take **Manager-owned dependencies** from the **manager**:
    - `cl := mgr.GetClient()`
    - other manager-owned deps when needed (scheme, cache, recorder, etc.).
  - Register required **runnables**/**sources** on the **manager** (if any):
    - example: cache initializers added via `mgr.Add(...)` (often after leader election).
  - Construct the reconciler (composition root for the package):
    - `rec := NewReconciler(cl, <otherDeps...>)`
  - Wire controller-runtime builder in a single fluent chain:
    - `.ControllerManagedBy(mgr).Named(<ControllerName>)`
    - `.For(&<apiObject>{}, builder.WithPredicates(...))`
    - `.Watches(...)` when the controller reacts to additional objects/events
    - `.WithOptions(controller.Options{MaxConcurrentReconciles: 10})` by default
    - `.Complete(rec)`

  Example: minimal `BuildController` skeleton (illustrative)

  ```go
  package examplecontroller

  import (
      "sigs.k8s.io/controller-runtime/pkg/builder"
      "sigs.k8s.io/controller-runtime/pkg/client"
      "sigs.k8s.io/controller-runtime/pkg/controller"
      "sigs.k8s.io/controller-runtime/pkg/event"
      "sigs.k8s.io/controller-runtime/pkg/manager"
      "sigs.k8s.io/controller-runtime/pkg/predicate"

      "example.com/api/v1alpha1"
  )

  const ExampleControllerName = "example_controller"

  func BuildController(mgr manager.Manager) error {
      cl := mgr.GetClient()

      // Optional wiring-only dependencies/runnables:
      // src := NewSomethingInitializer(mgr)
      // if err := mgr.Add(src); err != nil { return fmt.Errorf("adding initializer: %w", err) }

      rec := NewReconciler(cl /*, src */)

      return builder.ControllerManagedBy(mgr).
          Named(ExampleControllerName).
          For(&v1alpha1.Example{}, builder.WithPredicates(
              predicate.Funcs{
                  UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                      if e.ObjectNew.GetGeneration() != e.ObjectOld.GetGeneration() {
                          return true
                      }
                      return false
                  },
              },
          )).
          WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
          Complete(rec)
  }
  ```

- **predicates**/**filters** in **`controller.go`** (**MUST**):
  - Keep them lightweight and **mechanical** (no **I/O**, no multi-step **domain/business** reasoning).
  - Prefer typed events (`event.TypedUpdateEvent[client.Object]`).
  - **predicates** **MUST NOT** contain **domain/business** logic — only detect changes in fields.
    - Example of business logic (forbidden in predicates): “check presence/validity of required labels”.
  - If **Reconciliation business logic** uses `.status.conditions` (or any condition-driven logic), **predicate** **MUST** react to **`metadata.generation`** (**Generation**) changes.
    - Note: if you only need to react to **spec changes**, filtering by `generation` is usually sufficient (for CRDs, `generation` is  bumped on spec changes).
    - Important: **metadata-only changes** (labels/annotations/finalizers/ownerRefs) may **NOT** bump `generation`. If your controller must react to them, compare them explicitly (e.g. `GetLabels()`, `GetAnnotations()`, `GetFinalizers()`, `GetOwnerReferences()`).
  - **MUST NOT** generate noop handlers:
    - if a **predicate** handler (`CreateFunc`/`UpdateFunc`/`DeleteFunc`/`GenericFunc`) would only `return true`, omit it.
    - **MUST NOT** block `GenericFunc` unless there is a very explicit reason (prefer allowing reconcile).
  - Performance (**MUST**):
    - **predicates** are hot-path: minimize allocations and CPU (no **DeepCopy**, no reflection, avoid heavy comparisons).
    - still ensure they filter enough so that **reconcile loop** runs only when needed (otherwise the **reconcile loop** becomes the hotspot).
  - Typical use-cases:
    - reconcile only when a single field/label you own is out of sync and needs a quick correction;
    - reconcile on `generation` changes when status/conditions logic depends on spec changes.


  - **object** access in **predicates** (**MUST**):
    - Priority order:
      - `client.Object` getters
      - `obju` for conditions
      - API mechanical helpers
      - direct fields (last resort)
    - If a field is available via `client.Object` methods, you MUST use those methods.
      - Examples: `GetGeneration()`, `GetName()`, `GetNamespace()`, `GetLabels()`, `GetAnnotations()`, `GetFinalizers()`, `GetOwnerReferences()`.

      Example: use `client.Object` methods (no cast) — react to `generation` (inline style)
      (requires Go 1.21+ for `maps`/`slices`; and `k8s.io/apimachinery/pkg/api/equality` for `apiequality`)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // If reconciliation uses status.conditions (or any generation-driven logic),
                  // react to generation changes for spec-driven updates; if you also need to react
                  // to metadata-only changes (labels/annotations/finalizers/ownerRefs), compare them explicitly.
                  if e.ObjectNew.GetGeneration() != e.ObjectOld.GetGeneration() {
                      return true
                  }

                  // If your reconciliation uses labels, reconcile on label changes (metadata-only updates don't bump generation).
                  if !maps.Equal(e.ObjectNew.GetLabels(), e.ObjectOld.GetLabels()) {
                      return true
                  }

                  // If your reconciliation uses finalizers, reconcile on finalizer changes (metadata-only updates don't bump generation).
                  if !slices.Equal(e.ObjectNew.GetFinalizers(), e.ObjectOld.GetFinalizers()) {
                      return true
                  }

                  // If your reconciliation uses ownerRefs, reconcile on ownerRef changes (metadata-only updates don't bump generation).
                  // Note: this is order-sensitive; if order changes, we reconcile (safe/conservative).
                  if !apiequality.Semantic.DeepEqual(e.ObjectNew.GetOwnerReferences(), e.ObjectOld.GetOwnerReferences()) {
                      return true
                  }

                  // Ignore pure status updates to avoid reconcile loops.
                  return false
              },
              // No CreateFunc/DeleteFunc/GenericFunc: omit handlers that would only "return true".
          },
      )
      ```

    - If you need to compare **conditions** in **predicates** (**MUST**):
      - Use `objutilv1` imported as `obju` (do NOT open-code `.status.conditions` comparison).
      - Prefer:
        - `obju.AreConditionsSemanticallyEqual(...)` when you need the whole condition meaning (Type/Status/Reason/Message/ObservedGeneration).
        - `obju.AreConditionsEqualByStatus(...)` when only Status matters (Type+Status).

      Example: compare condition(s) via `obju` (mechanical checks only)
      ```go
      import obju "github.com/deckhouse/sds-replicated-volume/api/objutilv1"

      predicate.Funcs{
          UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
              newObj, okNew := e.ObjectNew.(obju.StatusConditionObject)
              oldObj, okOld := e.ObjectOld.(obju.StatusConditionObject)
              if !okNew || !okOld || newObj == nil || oldObj == nil {
                  // Be conservative if we cannot type-assert.
                  return true
              }

              // Compare full condition meaning:
              if !obju.AreConditionsSemanticallyEqual(newObj, oldObj, ExampleCondReadyType) {
                  return true
              }

              // Or compare only Type+Status:
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj, ExampleCondReadyType) { return true }
              //
              // Or compare several condition types:
              // if !obju.AreConditionsSemanticallyEqual(newObj, oldObj, ExampleCondReadyType, ExampleCondOnlineType) { return true }
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj, ExampleCondReadyType, ExampleCondOnlineType) { return true }
              //
              // Or compare all condition types present in either object:
              // if !obju.AreConditionsSemanticallyEqual(newObj, oldObj) { return true }
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj) { return true }

              return false
          },
      }
      ```

    - If `client.Object` methods are not enough for the fields you need, use `Get*`/`Has*`/`Equals*` helpers from the API type of the object.
      - If the object is from this repo API and such mechanical helpers are missing, prefer adding them to the API (still no business logic) and document the decision in code (short comment) before introducing ad-hoc direct field access in the controller.

      Example: use API helpers when `client.Object` methods are not enough (cast only to call helpers, inline style)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // We need API helper methods → cast is justified.
                  oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                  newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                  if !okOld || !okNew || oldObj == nil || newObj == nil {
                      return true
                  }

                  // Mechanical change detection via API helpers (no business logic here).
                  if !newObj.HasFoo() {
                      return true
                  }
                  if !newObj.FooEquals(oldObj.GetFoo()) {
                      return true
                  }

                  return false
              },
          },
      )
      ```


    - If there are no `client.Object` methods and no API helpers, read object fields directly.

      Example: direct field access when there are no `client.Object` methods and no API helpers (inline style)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // We need direct field reads → cast is justified.
                  oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                  newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                  if !okOld || !okNew || oldObj == nil || newObj == nil {
                      return true
                  }

                  // Field-level change detection (keep it small and explicit).
                  if newObj.Spec.Replicas != oldObj.Spec.Replicas {
                      return true
                  }
                  if newObj.Spec.Mode != oldObj.Spec.Mode {
                      return true
                  }

                  return false
              },
          },
      )
      ```

- Type assertions/casts in **predicates** (**MUST**):
  - If you do cast and can't safely classify the event (type-assert fails / nil), be conservative: return `true` (allow reconcile).

    Example: safe cast in predicates (inline style)
    ```go
    builder.WithPredicates(
        predicate.Funcs{
            UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                // We need API helper methods or direct field reads → cast is justified.
                oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                if !okOld || !okNew || oldObj == nil || newObj == nil {
                    // Be conservative: if we can't type-assert, allow reconcile.
                    return true
                }

                // predicate logic goes here
                return false
            },
        },
    )
    ```

  - Type-assert/cast to a concrete API type ONLY when `client.Object` methods are not enough for what you need.

    Example: do NOT cast when `client.Object` methods are sufficient (inline style)
    ```go
    builder.WithPredicates(
        predicate.Funcs{
            UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                // ✅ GOOD: no type cast needed for name/namespace.
                keyChanged := e.ObjectNew.GetNamespace() != e.ObjectOld.GetNamespace() ||
                    e.ObjectNew.GetName() != e.ObjectOld.GetName()

                // ❌ BAD: pointless cast just to read metadata fields.
                // newObj := e.ObjectNew.(*v1alpha1.Example)
                // _ = newObj.Name

                return keyChanged
            },
        },
    )
    ```

- MaxConcurrentReconciles (MUST):
  - Configure `.WithOptions(controller.Options{MaxConcurrentReconciles: 10})` unless there is a strong, explicit reason not to.
  - If deviating from 10, document the reason near the options.

- Watching child resources (MUST):
  - Watch **child resources** either:
    - by owner reference (when this controller is the owner/controller of the child objects), or
    - by an explicit field/index (when children may be created by others: another controller or a user).
  - If it is not obvious which model applies for a given child object:
    - default to the safest *correctness* choice (prefer being conservative and reconciling more over missing important events), and
    - add a short comment explaining why this watch strategy was chosen (and what would justify switching to the alternative).

  Example: watch child objects by owner reference (controller is the owner)
  ```go
  builder.ControllerManagedBy(mgr).
      Named(ExampleControllerName).
      For(&v1alpha1.Example{}, builder.WithPredicates(
          predicate.Funcs{
              // predicate logic goes here
          },
      )).
      Owns(
          &v1alpha1.ExampleChild{},
          builder.WithPredicates(
              predicate.Funcs{
                  // child predicate logic goes here
              },
          ),
      ). // ownerRef-based mapping
      WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
      Complete(rec)
  ```

  Example: watch child objects by explicit field/index (children may be created by others)
  ```go
  builder.ControllerManagedBy(mgr).
      Named(ExampleControllerName).
      For(&v1alpha1.Example{}, builder.WithPredicates(
          predicate.Funcs{
              // predicate logic goes here
          },
      )).
      Watches(
          &v1alpha1.ExampleChild{},
          handler.EnqueueRequestsFromMapFunc(func(ctx context.Context, obj client.Object) []reconcile.Request {
              ch, ok := obj.(*v1alpha1.ExampleChild)
              if !ok || ch == nil {
                  return nil
              }
              return []reconcile.Request{{NamespacedName: types.NamespacedName{
                  Namespace: ch.Namespace,
                  Name:      ch.Spec.ParentName,
              }}}
          }),
          builder.WithPredicates(
              predicate.Funcs{
                  // child predicate logic goes here
              },
          ),
      ).
      WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
      Complete(rec)
  ```

- What MUST NOT be in `controller.go`:
  - any `Reconcile(...)` implementation;
  - any Kubernetes API I/O beyond manager wiring (`Get/List/Create/Update/Patch/Delete`);
  - any non-trivial domain/business decisions (placement/scheduling/state machines/condition computation).
