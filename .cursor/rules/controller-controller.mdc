---
description: Controller entrypoint rules for controller.go (wiring-only, controller-runtime builder, runnables, predicates)
globs:
  - "images/controller/internal/controllers/**/controller.go"
alwaysApply: true
---

- `controller.go` purpose (MUST):
  - `controller.go` is the wiring-only entrypoint of a controller package.
  - It owns controller-runtime builder configuration, sources/runnables registration and reconciler construction.
  - It MUST NOT contain reconciliation business logic (that belongs to `reconciler.go`).

- `controller.go` layout (MUST):
  - `const <ControllerName> = "<name>"` (stable controller name).
  - `BuildController(mgr manager.Manager) error` as the package entrypoint.
  - Predicates/filters MUST be present to reduce reconcile noise.

- What belongs in `BuildController` (MUST):
  - Take dependencies from manager:
    - `cl := mgr.GetClient()`
    - other manager-owned deps when needed (scheme, cache, recorder, etc.).
  - Register required runnables/sources on manager (if any):
    - example: idpool/cache initializers added via `mgr.Add(...)` (often after leader election).
  - Construct the reconciler (composition root for the package):
    - `rec := NewReconciler(cl, <otherDeps...>)`
  - Wire controller-runtime builder in a single fluent chain:
    - `.ControllerManagedBy(mgr).Named(<ControllerName>)`
    - `.For(&<apiObject>{}, builder.WithPredicates(...))`
    - `.Watches(...)` when the controller reacts to additional objects/events
    - `.WithOptions(controller.Options{MaxConcurrentReconciles: 10})` by default
    - `.Complete(rec)`

  Example: minimal `BuildController` skeleton (illustrative)

  ```go
  package examplecontroller

  import (
      "sigs.k8s.io/controller-runtime/pkg/builder"
      "sigs.k8s.io/controller-runtime/pkg/client"
      "sigs.k8s.io/controller-runtime/pkg/controller"
      "sigs.k8s.io/controller-runtime/pkg/event"
      "sigs.k8s.io/controller-runtime/pkg/manager"
      "sigs.k8s.io/controller-runtime/pkg/predicate"

      "example.com/api/v1alpha1"
  )

  const ExampleControllerName = "example_controller"

  func BuildController(mgr manager.Manager) error {
      cl := mgr.GetClient()

      // Optional wiring-only dependencies/runnables:
      // src := NewSomethingInitializer(mgr)
      // if err := mgr.Add(src); err != nil { return fmt.Errorf("adding initializer: %w", err) }

      rec := NewReconciler(cl /*, src */)

      return builder.ControllerManagedBy(mgr).
          Named(ExampleControllerName).
          For(&v1alpha1.Example{}, builder.WithPredicates(
              predicate.Funcs{
                  UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                      if e.ObjectNew.GetGeneration() != e.ObjectOld.GetGeneration() {
                          return true
                      }
                      return false
                  },
              },
          )).
          WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
          Complete(rec)
  }
  ```

- Predicates/filters in `controller.go` (MUST):
  - Keep them lightweight and mechanical (no I/O, no multi-step domain reasoning).
  - Prefer typed events (`event.TypedUpdateEvent[client.Object]`).
  - Predicates MUST NOT contain business logic — only detect changes in fields.
    - Example of business logic (forbidden in predicates): “check presence/validity of required labels”.
  - If reconciliation uses `.status.conditions` (or any condition-driven logic), predicate MUST react to `metadata.generation` changes.
    - Note: when `generation` changes, there is no point in additionally checking spec/labels/metadata deltas for the primary object:
      - changes to spec, labels, ownerRefs, finalizers, etc. will change `generation` anyway.
  - Do not generate noop handlers:
    - if a predicate handler (`CreateFunc`/`UpdateFunc`/`DeleteFunc`/`GenericFunc`) would only `return true`, omit it.
    - do NOT block `GenericFunc` unless there is a very explicit reason (prefer allowing reconcile).
  - Performance (MUST):
    - predicates are hot-path: minimize allocations and CPU (no DeepCopy, no reflection, avoid heavy comparisons).
    - still ensure they filter enough so that reconcile runs only when needed (otherwise reconcile becomes the hotspot, which is worse).
  - Typical use-cases:
    - reconcile only when a single field/label you own is out of sync and needs a quick correction;
    - reconcile on `generation` changes when status/conditions logic depends on spec changes.


  - Object access in predicates (MUST):
    - If a field is available via `client.Object` methods, you MUST use those methods.
      - Examples: `GetGeneration()`, `GetName()`, `GetNamespace()`, `GetLabels()`, `GetAnnotations()`.

      Example: use `client.Object` methods (no cast) — react to `generation` (inline style)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // If reconciliation uses status.conditions (or any generation-driven logic),
                  // react to generation changes and do NOT duplicate checks for spec/labels/metadata.
                  if e.ObjectNew.GetGeneration() != e.ObjectOld.GetGeneration() {
                      return true
                  }

                  // Otherwise ignore pure status updates to avoid reconcile loops.
                  return false
              },
              // No CreateFunc/DeleteFunc/GenericFunc: omit handlers that would only "return true".
          },
      )
      ```

    - If you need to compare conditions in predicates (MUST):
      - Use `objutilv1` imported as `obju` (do NOT open-code `.status.conditions` comparison).
      - Prefer:
        - `obju.AreConditionsSemanticallyEqual(...)` when you need the whole condition meaning (Type/Status/Reason/Message/ObservedGeneration).
        - `obju.AreConditionsEqualByStatus(...)` when only Status matters (Type+Status).

      Example: compare condition(s) via `obju` (mechanical checks only)
      ```go
      import obju "github.com/deckhouse/sds-replicated-volume/api/objutilv1"

      predicate.Funcs{
          UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
              newObj, okNew := e.ObjectNew.(obju.StatusConditionObject)
              oldObj, okOld := e.ObjectOld.(obju.StatusConditionObject)
              if !okNew || !okOld || newObj == nil || oldObj == nil {
                  // Be conservative if we cannot type-assert.
                  return true
              }

              // Compare full condition meaning:
              if !obju.AreConditionsSemanticallyEqual(newObj, oldObj, ExampleCondReadyType) {
                  return true
              }

              // Or compare only Type+Status:
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj, ExampleCondReadyType) { return true }
              //
              // Or compare several condition types:
              // if !obju.AreConditionsSemanticallyEqual(newObj, oldObj, ExampleCondReadyType, ExampleCondOnlineType) { return true }
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj, ExampleCondReadyType, ExampleCondOnlineType) { return true }
              //
              // Or compare all condition types present in either object:
              // if !obju.AreConditionsSemanticallyEqual(newObj, oldObj) { return true }
              // if !obju.AreConditionsEqualByStatus(newObj, oldObj) { return true }

              return false
          },
      }
      ```

    - Otherwise, use `Get*`/`Has*`/`Equals*` helpers from the API type of the object.
      - If the object is from this repo API and such mechanical helpers are missing, prefer adding them to the API (still no business logic) and ask the user before introducing ad-hoc direct field access in the controller.

      Example: use API helpers when `client.Object` methods are not enough (cast only to call helpers, inline style)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // We need API helper methods → cast is justified.
                  oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                  newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                  if !okOld || !okNew || oldObj == nil || newObj == nil {
                      return true
                  }

                  // Mechanical change detection via API helpers (no business logic here).
                  if !newObj.HasFoo() {
                      return true
                  }
                  if !newObj.FooEquals(oldObj.GetFoo()) {
                      return true
                  }

                  return false
              },
          },
      )
      ```


    - Otherwise, read object fields directly.

      Example: direct field access when there are no `client.Object` methods and no API helpers (inline style)
      ```go
      builder.WithPredicates(
          predicate.Funcs{
              UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                  // We need direct field reads → cast is justified.
                  oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                  newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                  if !okOld || !okNew || oldObj == nil || newObj == nil {
                      return true
                  }

                  // Field-level change detection (keep it small and explicit).
                  if newObj.Spec.Replicas != oldObj.Spec.Replicas {
                      return true
                  }
                  if newObj.Spec.Mode != oldObj.Spec.Mode {
                      return true
                  }

                  return false
              },
          },
      )
      ```

- Type assertions/casts in predicates (MUST):
  - If you do cast and can't safely classify the event (type-assert fails / nil), be conservative: return `true` (allow reconcile).

    Example: safe cast in predicates (inline style)
    ```go
    builder.WithPredicates(
        predicate.Funcs{
            UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                // We need API helper methods or direct field reads → cast is justified.
                oldObj, okOld := e.ObjectOld.(*v1alpha1.Example)
                newObj, okNew := e.ObjectNew.(*v1alpha1.Example)
                if !okOld || !okNew || oldObj == nil || newObj == nil {
                    // Be conservative: if we can't type-assert, allow reconcile.
                    return true
                }

                // predicate logic goes here
                return false
            },
        },
    )
    ```

  - Type-assert/cast to a concrete API type ONLY when `client.Object` methods are not enough for what you need.

    Example: do NOT cast when `client.Object` methods are sufficient (inline style)
    ```go
    builder.WithPredicates(
        predicate.Funcs{
            UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool {
                // ✅ GOOD: no type cast needed for name/namespace.
                keyChanged := e.ObjectNew.GetNamespace() != e.ObjectOld.GetNamespace() ||
                    e.ObjectNew.GetName() != e.ObjectOld.GetName()

                // ❌ BAD: pointless cast just to read metadata fields.
                // newObj := e.ObjectNew.(*v1alpha1.Example)
                // _ = newObj.Name

                return keyChanged
            },
        },
    )
    ```

- MaxConcurrentReconciles (MUST):
  - Configure `.WithOptions(controller.Options{MaxConcurrentReconciles: 10})` unless there is a strong, explicit reason not to.
  - If deviating from 10, document the reason near the options.

- Watching child resources (MUST):
  - Watch child objects either:
    - by owner reference (when this controller is the owner/controller of the child objects), or
    - by an explicit field/index (when children may be created by others: another controller or a user).
  - If it is not obvious which model applies for a given child object, ask the user before choosing the watch strategy.

  Example: watch child objects by owner reference (controller is the owner)
  ```go
  builder.ControllerManagedBy(mgr).
      Named(ExampleControllerName).
      For(&v1alpha1.Example{}, builder.WithPredicates(
          predicate.Funcs{
              // predicate logic goes here
          },
      )).
      Owns(
          &v1alpha1.ExampleChild{},
          builder.WithPredicates(
              predicate.Funcs{
                  // child predicate logic goes here
              },
          ),
      ). // ownerRef-based mapping
      WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
      Complete(rec)
  ```

  Example: watch child objects by explicit field/index (children may be created by others)
  ```go
  builder.ControllerManagedBy(mgr).
      Named(ExampleControllerName).
      For(&v1alpha1.Example{}, builder.WithPredicates(
          predicate.Funcs{
              // predicate logic goes here
          },
      )).
      Watches(
          &v1alpha1.ExampleChild{},
          handler.EnqueueRequestsFromMapFunc(func(ctx context.Context, obj client.Object) []reconcile.Request {
              ch, ok := obj.(*v1alpha1.ExampleChild)
              if !ok || ch == nil {
                  return nil
              }
              return []reconcile.Request{{NamespacedName: types.NamespacedName{
                  Namespace: ch.Namespace,
                  Name:      ch.Spec.ParentName,
              }}}
          }),
          builder.WithPredicates(
              predicate.Funcs{
                  // child predicate logic goes here
              },
          ),
      ).
      WithOptions(controller.Options{MaxConcurrentReconciles: 10}).
      Complete(rec)
  ```

- What MUST NOT be in `controller.go`:
  - any `Reconcile(...)` implementation;
  - any Kubernetes API I/O beyond manager wiring (`Get/List/Create/Update/Patch/Delete`);
  - any non-trivial domain/business decisions (placement/scheduling/state machines/condition computation).
