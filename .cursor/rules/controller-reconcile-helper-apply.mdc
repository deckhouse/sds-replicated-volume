---
description: Controller reconciliation helpers — ApplyReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# ApplyReconcileHelper

This document defines naming and contracts for **ApplyReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- **`apply*`** helpers are **pure, deterministic, strictly non-I/O** “in-memory write” steps.
- **ApplyReconcileHelpers** (`apply*`) are **pure**, **deterministic**, strictly **non-I/O** “in-memory write” steps.
- They take a previously computed **desired value** and mutate `obj` in place for **exactly one** **patch domain** (**main patch domain** or **status patch domain**).
- They **MUST NOT** perform **Kubernetes API I/O**, use the controller-runtime client, call **DeepCopy**, or execute patches / make **patch ordering** or **patch type decision** decisions.
- They **MUST** treat `desired` (and any other inputs) as **read-only inputs** and **MUST NOT** mutate it (including via **Aliasing**); when copying maps/slices from `desired` into `obj`, **Clone** to avoid sharing.
- If both **main patch domain** and **status patch domain** need changes, use two **ApplyReconcileHelpers** (one per **patch domain**) and compose them in **Reconcile methods**.

---

## Definition

An **ApplyReconcileHelper** (“apply helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- applies a previously computed **desired value** to the in-memory object, and
- mutates **exactly one patch domain** in place (**main resource** or **status subresource**), without executing any **patch request**.

Typical apply helpers perform the “mechanical write” step right after **Reconcile methods** create a **patch base** and right before they patch that domain.

---

## Naming

- An **ApplyReconcileHelper** name **MUST** start with `apply` / `Apply`.
- **ApplyReconcileHelpers** **MUST** be domain-explicit in the name when ambiguity is possible (ambiguity is possible when the applied artifact name refers to a field/group that exists in both `.spec` (**main patch domain**) and `.status` (**status patch domain**) of the same **object**):
  - `applyMain*` / `ApplyMain*` (**main patch domain**)
  - `applyStatus*` / `ApplyStatus*` (**status patch domain**)
- **ApplyReconcileHelpers** **SHOULD NOT** include `Main` / `Status` in the name when there is no such ambiguity.
- For main-domain **ApplyReconcileHelpers**, the name **MUST** also include the concrete artifact being applied (e.g. labels, annotations, or a specific spec field/group) — avoid names that imply “the whole main”.
- **ApplyReconcileHelpers** names **MUST NOT** sound like persistence (`applyPatch`, `applyUpdate`, `applyToAPI`) — apply helpers only mutate in-memory state.
- **ApplyReconcileHelpers** names **MUST NOT** include `Desired` / `Actual` unless the applied “thing” name includes `Desired` / `Actual`.
- **ApplyReconcileHelpers** names **SHOULD** name the “thing” being applied:
  - `applyLabels(obj, desiredLabels)`
  - `applySpecFoo(obj, desiredFoo)`
  - `applyStatus(obj, desired)`
  - `applyConditions(obj, desiredConditions)`

---

## Preferred signatures

- For **ApplyReconcileHelpers** (`apply*`), the simplest signature from the variants below that preserves explicit dependencies and purity **SHOULD** be chosen.
- If additional signature variants are explicitly permitted elsewhere in this document, they **MAY** also be used.

### Simple apply
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo)
```

Or, if an error is realistically possible:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) error
```

---

## Receivers

- **ApplyReconcileHelpers** **MUST** be plain functions (no `Reconciler` receiver).

---

## I/O boundaries

**ApplyReconcileHelpers** **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

**ApplyReconcileHelpers** **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads) (except setting `metav1.Condition.LastTransitionTime`, typically indirectly via `obju.SetStatusCondition`);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: apply helpers should be **deterministic** “in-memory write” steps; all API interactions and patch execution belong to **Reconcile methods**.

---

## Determinism contract

An **ApplyReconcileHelper** **MUST** be **deterministic** given its explicit inputs and intended mutation domain.

See the common determinism contract in `controller-reconcile-helper.mdc`.

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract

`apply*` / `Apply*` **MUST** treat all inputs except the target mutation on `obj` as read-only:

- it **MUST NOT** mutate inputs other than `obj` (e.g., `desired`, templates, computed structs);
- it **MUST** mutate only the intended **patch domain** on `obj` (**main resource** **or** **status subresource**), treating the other domain as read-only;
- it **MUST NOT** perform in-place modifications through aliases to non-`obj` data.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation

- `apply*` / `Apply*` **MUST** mutate `obj` in-place for **exactly one** patch domain:
  - **main resource** (**metadata + spec + non-status fields**), **or**
  - **status subresource** (`.status`).
- An **ApplyReconcileHelper** **MUST NOT** mutate both domains in the same function.
- If you need to apply **desired values** to both domains, you **MUST** implement **two** apply helpers and call them separately from **Reconcile methods**.

✅ Separate apply helpers (GOOD)
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFooMain)
func applyDesiredFooStatus(obj *v1alpha1.Foo, desired DesiredFooStatus)
```

❌ Mixed apply (BAD)
```go
func applyDesiredFoo(
    obj *v1alpha1.Foo,
    desiredMain DesiredFooMain,
    desiredStatus DesiredFooStatus,
) {
    // mutates both spec/metadata and status in one helper
}
```

---

## Composition

- An **ApplyReconcileHelper** **MAY** apply multiple related fields in one pass **within a single** **patch domain**.
- If applied fields represent one conceptual **desired state**, they **SHOULD** be passed as one `desired` value (small struct) rather than a long parameter list.
- If applied changes are distinguishable and used independently, they **SHOULD** be split into separate `apply*` helpers and composed in **Reconcile methods** (not by making apply helpers depend on each other).

---

## Flow phases and **Outcome**

- **ApplyReconcileHelpers** **MUST NOT** create a `reconcile/flow` **phase** (they do not accept `ctx context.Context`; see `controller-reconcile-helper.mdc`).
- **ApplyReconcileHelpers** **MUST NOT** return **Outcome** (in code: `flow.Outcome`) (they are “in-memory write” steps).
  - If a failure is possible, return `error` and let the calling function convert it into `flow.Fail(err)` (or equivalent **flow** handling).

---

## Error handling

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- ApplyReconcileHelpers (`apply*`) **SHOULD** be non-failing.
  - If an **ApplyReconcileHelper** returns `error`, it **MUST** be only for **local validation** failures (e.g., nil pointers, impossible desired shape).
  - It **MUST NOT** wrap/enrich errors (external errors should not exist in `apply*`), and **MUST NOT** include **object identity** (e.g. `namespace/name`, UID, object key).
  - Any action/**object identity** context belongs to the calling function.

---

## Common anti-patterns (**MUST NOT**)

❌ Doing any Kubernetes API I/O (client usage / API calls in apply):
```go
func applyDesiredFoo(ctx context.Context, c client.Client, obj *v1alpha1.Foo, desired DesiredFoo) error {
    // forbidden: apply helpers are non-I/O
    return c.Update(ctx, obj)
}
```

❌ Executing patches or making patch decisions inside apply:
```go
func applyDesiredFoo(ctx context.Context, c client.Client, obj, base *v1alpha1.Foo, desired DesiredFoo) error {
    // forbidden: patch execution belongs to Reconcile methods / PatchReconcileHelpers
    obj.Spec = desired.Spec
    return c.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Calling `DeepCopy` inside apply:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    obj.Spec = desired.Spec
}
```

❌ Returning `flow.Outcome` / doing flow control inside apply:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) flow.Outcome {
    obj.Spec = desired.Spec
    return flow.Continue() // forbidden: apply helpers do not return flow control
}
```

❌ Adding logging/phases to apply helpers (they must stay tiny and have no `ctx`):
```go
func applyDesiredFoo(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) error {
    l := log.FromContext(ctx)
    l.Info("applying desired foo") // forbidden: apply helpers do not log / do not accept ctx
    obj.Spec = desired.Spec
    return nil
}
```

❌ Mutating both patch domains in one apply helper:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desiredMain DesiredFooMain, desiredStatus DesiredFooStatus) {
    obj.Spec = desiredMain.Spec      // main domain
    obj.Status = desiredStatus.State // status domain
    // forbidden: apply must touch exactly one patch domain
}
```

❌ Implementing business logic inside apply (deciding desired state while applying it):
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) {
    // forbidden: decisions belong to compute/ensure; apply is mechanical
    if obj.Spec.Mode == "special" {
        desired.Replicas = 5 // also mutates desired (see below)
    }
    obj.Spec.Replicas = desired.Replicas
}
```

❌ Mutating `desired` (or any other non-`obj` input):
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    desired.Labels["x"] = "y" // forbidden: desired is read-only
    obju.SetLabels(obj, desired.Labels)
}
```

❌ Sharing maps/slices from `desired` into `obj` (aliasing):
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    obj.SetLabels(desired.Labels) // forbidden: shares map backing storage

    // later mutation now also mutates `desired.Labels` through aliasing
    obj.GetLabels()["owned"] = "true"
}
```

❌ Writing nondeterministic ordered fields (map iteration order leaks into slices):
```go
func applyDesiredFinalizers(obj *v1alpha1.Foo, desired DesiredFinalizers) {
    finals := make([]string, 0, len(desired.Set))
    for f := range desired.Set { // map iteration order is random
        finals = append(finals, f)
    }
    // missing sort => nondeterministic object state => patch churn
    obj.SetFinalizers(finals)
}
```

❌ Manual metadata/conditions manipulation when `objutilv1` must be used:
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    // forbidden in this codebase: do not open-code label map edits
    if obj.Labels == nil {
        obj.Labels = map[string]string{}
    }
    obj.Labels["a"] = "b"
}
```
