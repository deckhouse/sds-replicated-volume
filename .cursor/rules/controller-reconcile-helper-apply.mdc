---
description: Controller reconciliation helpers — ApplyReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# ApplyReconcileHelper

This document defines naming and contracts for **ApplyReconcileHelper** functions/methods.

Common terminology and rules for any ReconcileHelper live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **MAY**.

---

## TL;DR (MUST)

- `apply*` helpers are **pure, deterministic, strictly non-I/O** “in-memory write” steps.
- They take a **previously computed desired value** and **mutate `obj` in place** for **exactly one patch domain** (main **or** status).
- They **MUST NOT** talk to the Kubernetes API, use controller-runtime client, call `DeepCopy`, or execute patches / make patch ordering or patch type decisions.
- They **MUST** treat `desired` (and any other inputs) as **read-only** and **MUST NOT** mutate it (including via aliasing); when copying maps/slices from `desired` into `obj`, **clone** to avoid sharing.
- If both main and status need changes, use **two** apply helpers (one per domain) and compose them in Reconcile methods.

---

## ALLOW / DENY cheat sheet

**ALLOW (MAY):**
- Mutate the caller-owned `obj` **in place** for **exactly one** patch domain:
  - main resource (metadata/spec/non-status), **or**
  - status subresource (`.status`).
- Mechanically “write desired into obj” (copy fields, set labels/annotations/finalizers/conditions) with no business decisions.
- Treat `desired` and all other inputs as read-only; if you need to transform/normalize before applying, do it on **local clones**.
- Clone maps/slices from `desired` before setting them on `obj` to avoid aliasing:
  - `maps.Clone(desired.Labels)`, `slices.Clone(desired.Items)`, `append([]T(nil), desired.Items...)`.
- Ensure deterministic object state:
  - if you build ordered slices from sets/maps, **sort** before setting;
  - write fields in a stable, canonical form.
- Use `objutilv1` (imported as `obju`) for labels/annotations/finalizers/ownerRefs/conditions operations where required by the codebase.
- Return `error` only for truly exceptional local validation failures (nil desired pointers, impossible desired shape, etc.).

**DENY (MUST NOT):**
- Any controller-runtime client usage or Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`), directly or indirectly.
- `DeepCopy` in any form (`obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.).
- Executing patches (`Patch` / `Status().Patch`) or making patch ordering / patch type decisions.
- Flow control responsibilities:
  - no `flow.BeginPhase`, no logging, no `ctx` argument,
  - no returning `flow.Outcome`.
- Mutating more than one patch domain in the same helper (main + status together).
- Mutating `desired` or any other non-`obj` inputs (including via aliasing of maps/slices).
- Sharing reference-like data from `desired` into `obj` (aliasing), e.g. `obj.SetLabels(desired.Labels)` without cloning.
- Hidden I/O / nondeterminism:
  - `time.Now()` / `time.Since(...)` (except timestamps set indirectly via `obju` condition helpers where unavoidable),
  - `rand.*` / UUID generation,
  - `os.Getenv`, reading files,
  - network calls of any kind.
- Embedding business logic (deciding desired state) inside apply helpers; decisions belong to compute/ensure/Reconcile methods.

---

## Definition (MUST)

An **ApplyReconcileHelper** (“apply helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- applies a previously computed **desired value** to the in-memory object, and
- mutates **exactly one patch domain** in place (main resource **or** status subresource), without executing any patch request.

Typical apply helpers perform the “mechanical write” step right after Reconcile methods create a patch base and right before they patch that domain.

---

## Naming (MUST)

- An **ApplyReconcileHelper** name **MUST** start with `apply` / `Apply`.
- ApplyReconcileHelpers **MUST** be domain-explicit in the name when ambiguity is possible:
  - `applyMain*` / `ApplyMain*` (main resource)
  - `applyStatus*` / `ApplyStatus*` (status subresource)
- For main-domain ApplyReconcileHelpers, the name **MUST** also include the concrete artifact being applied (e.g. labels, annotations, or a specific spec field/group) — avoid names that imply “the whole main”.

Guidance (SHOULD):
- Name the desired artifact being applied:
  - `applyDesiredLabels(obj, desiredLabels)`
  - `applyDesiredSpecFoo(obj, desiredFoo)`
  - `applyDesiredStatus(obj, desired)`
  - `applyDesiredConditions(obj, desiredConditions)`
- Avoid names that sound like persistence (`applyPatch`, `applyUpdate`, `applyToAPI`) — apply helpers only mutate in-memory state.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and purity.

### Simple apply (SHOULD)
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo)
```

Or, if an error is realistically possible:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) error
```

---

## Receivers (MUST)

- ApplyReconcileHelpers **MUST** be plain functions (no `Reconciler` receiver).

---

## I/O boundaries (MUST)

ApplyReconcileHelpers **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

ApplyReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads) (except setting `metav1.Condition.LastTransitionTime`, typically indirectly via `obju.SetStatusCondition`);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: apply helpers should be deterministic “in-memory write” steps; all API interactions and patch execution belong to Reconcile methods.

---

## Determinism contract (MUST)

An ApplyReconcileHelper **MUST** be deterministic given its explicit inputs and intended mutation domain.

See the common determinism contract in `controller-reconcile-helper.mdc`.

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract (MUST)

`apply*` / `Apply*` **MUST** treat all inputs except the target mutation on `obj` as read-only:

- it **MUST NOT** mutate inputs other than `obj` (e.g., `desired`, templates, computed structs);
- it **MUST** mutate only the intended patch domain on `obj` (main resource **or** status subresource), treating the other domain as read-only;
- it **MUST NOT** perform in-place modifications through aliases to non-`obj` data.

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Patch-domain separation (MUST)

- `apply*` / `Apply*` **MUST** mutate `obj` in-place for **exactly one** patch domain:
  - main resource (**metadata + spec + non-status fields**), **or**
  - status subresource (`.status`).
- An ApplyReconcileHelper **MUST NOT** mutate both domains in the same function.
- If you need to apply desired values to both domains, you **MUST** implement **two** apply helpers and call them separately from Reconcile methods.

✅ Separate apply helpers (GOOD)
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFooMain)
func applyDesiredFooStatus(obj *v1alpha1.Foo, desired DesiredFooStatus)
```

❌ Mixed apply (BAD)
```go
func applyDesiredFoo(
    obj *v1alpha1.Foo,
    desiredMain DesiredFooMain,
    desiredStatus DesiredFooStatus,
) {
    // mutates both spec/metadata and status in one helper
}
```

---

## Composition (MUST)

- An ApplyReconcileHelper **MAY** apply multiple related fields in one pass **within a single patch domain**.
- If applied fields represent one conceptual “desired state”, they **SHOULD** be passed as one `desired` value (small struct) rather than a long parameter list.
- If applied changes are distinguishable and used independently, they **SHOULD** be split into separate `apply*` helpers and composed in Reconcile methods (not by making apply helpers depend on each other).

---

## Flow phases and `flow.Outcome` (MUST)

- ApplyReconcileHelpers **MUST NOT** create a `reconcile/flow` phase (they do not accept `ctx context.Context`; see `controller-reconcile-helper.mdc`).
- ApplyReconcileHelpers **MUST NOT** return `flow.Outcome` (they are “in-memory write” steps).
  - If a failure is possible, return `error` and let the caller convert it into `flow.Fail(err)` (or equivalent flow handling).

---

## Error handling (SHOULD)

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- ApplyReconcileHelpers (`apply*`) SHOULD be non-failing.
  - If an ApplyReconcileHelper returns `error`, it MUST be only for **local validation** failures (e.g., nil pointers, impossible desired shape).
  - It MUST NOT wrap/enrich errors (external errors should not exist in `apply*`), and MUST NOT include reconcile object identity (e.g. `namespace/name`, UID, object key).
  - Any action/object identity context belongs to the calling Reconcile method.

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API I/O (client usage / API calls in apply):
```go
func applyDesiredFoo(ctx context.Context, c client.Client, obj *v1alpha1.Foo, desired DesiredFoo) error {
    // forbidden: apply helpers are non-I/O
    return c.Update(ctx, obj)
}
```

❌ Executing patches or making patch decisions inside apply:
```go
func applyDesiredFoo(ctx context.Context, c client.Client, obj, base *v1alpha1.Foo, desired DesiredFoo) error {
    // forbidden: patch execution belongs to Reconcile methods / PatchReconcileHelpers
    obj.Spec = desired.Spec
    return c.Patch(ctx, obj, client.MergeFrom(base))
}
```

❌ Calling `DeepCopy` inside apply:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) {
    _ = obj.DeepCopy() // forbidden: DeepCopy belongs to Reconcile methods
    obj.Spec = desired.Spec
}
```

❌ Returning `flow.Outcome` / doing flow control inside apply:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) flow.Outcome {
    obj.Spec = desired.Spec
    return flow.Continue() // forbidden: apply helpers do not return flow control
}
```

❌ Adding logging/phases to apply helpers (they must stay tiny and have no `ctx`):
```go
func applyDesiredFoo(ctx context.Context, obj *v1alpha1.Foo, desired DesiredFoo) error {
    l := log.FromContext(ctx)
    l.Info("applying desired foo") // forbidden: apply helpers do not log / do not accept ctx
    obj.Spec = desired.Spec
    return nil
}
```

❌ Mutating both patch domains in one apply helper:
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desiredMain DesiredFooMain, desiredStatus DesiredFooStatus) {
    obj.Spec = desiredMain.Spec      // main domain
    obj.Status = desiredStatus.State // status domain
    // forbidden: apply must touch exactly one patch domain
}
```

❌ Implementing business logic inside apply (deciding desired state while applying it):
```go
func applyDesiredFoo(obj *v1alpha1.Foo, desired DesiredFoo) {
    // forbidden: decisions belong to compute/ensure; apply is mechanical
    if obj.Spec.Mode == "special" {
        desired.Replicas = 5 // also mutates desired (see below)
    }
    obj.Spec.Replicas = desired.Replicas
}
```

❌ Mutating `desired` (or any other non-`obj` input):
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    desired.Labels["x"] = "y" // forbidden: desired is read-only
    obju.SetLabels(obj, desired.Labels)
}
```

❌ Sharing maps/slices from `desired` into `obj` (aliasing):
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    obj.SetLabels(desired.Labels) // forbidden: shares map backing storage

    // later mutation now also mutates `desired.Labels` through aliasing
    obj.GetLabels()["owned"] = "true"
}
```

❌ Writing nondeterministic ordered fields (map iteration order leaks into slices):
```go
func applyDesiredFinalizers(obj *v1alpha1.Foo, desired DesiredFinalizers) {
    finals := make([]string, 0, len(desired.Set))
    for f := range desired.Set { // map iteration order is random
        finals = append(finals, f)
    }
    // missing sort => nondeterministic object state => patch churn
    obj.SetFinalizers(finals)
}
```

❌ Manual metadata/conditions manipulation when `objutilv1` must be used:
```go
func applyDesiredLabels(obj *v1alpha1.Foo, desired DesiredLabels) {
    // forbidden in this codebase: do not open-code label map edits
    if obj.Labels == nil {
        obj.Labels = map[string]string{}
    }
    obj.Labels["a"] = "b"
}
```
