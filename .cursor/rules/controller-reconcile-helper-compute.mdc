---
description: Controller reconciliation helpers — ComputeReconcileHelper
globs:
  - "images/controller/internal/controllers/rv_controller/reconciler.go"
alwaysApply: true
---

# ComputeReconcileHelper

This document defines naming and contracts for **ComputeReconcileHelper** functions/methods.

Common terminology and rules for any **ReconcileHelper** live in `controller-reconcile-helper.mdc`.

Normative keywords: **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY**.

---

## TL;DR

Summary only; if anything differs, follow normative sections below.

- `compute*` helpers are **pure, deterministic, strictly non-I/O** computations (no hidden I/O: no time/random/env/network).
- They compute **desired** (`computeDesired*`) and/or **actual (derived)** (`computeActual*`) values (and/or intermediate derived values), and return them (or write into explicit `out` args).
- They treat `obj` and all caller-provided inputs as **read-only** and **MUST NOT** mutate them (including via **aliasing** of maps/slices; **clone** before modifying derived maps/slices).
- They **MUST NOT** use **controller-runtime client**, talk to the **Kubernetes API**, call **`DeepCopy`**, execute patches, or make any **patch ordering** / **patch type decision**.
- If a compute helper returns `flow.Outcome`, it **MUST** use it only for **flow control** (continue/done/requeue) and/or **errors**.
- A compute helper **MUST NOT** use `flow.Outcome` change tracking (`ReportChanged`, `ReportChangedIf`) or optimistic-lock signaling (`RequireOptimisticLock`).
- If `computeDesired*` derives desired values for **both** main and status domains that will later be used by `IsUpToDate` and/or `Apply`, it **MUST** return **two separate** values (main + status), not a mixed struct.
- If a compute helper depends on previous compute output, the dependency **MUST** be explicit in the signature as args **after `obj`**.

---

## Definition

A **ComputeReconcileHelper** (“compute helper”) is a **ReconcileHelper** that is:

- **strictly non-I/O**, and
- performs **computations** from inputs and the current object state, and
- returns computed results (and optionally an error).

Typical compute helpers compute:
- **desired state** (`computeDesired*`) and/or
- **actual (derived) state** (`computeActual*`) and/or
- intermediate derived values used by later steps.

---

## Naming

- A **ComputeReconcileHelper** name **MUST** start with `compute` / `Compute`.
- ComputeReconcileHelpers for desired-state computations **MUST** use the form:
  - `computeDesired*` / `ComputeDesired*`.
- ComputeReconcileHelpers for actual-state computations **MUST** use the form:
  - `computeActual*` / `ComputeActual*`.
- ComputeReconcileHelpers that compute values for exactly one **patch domain** **MUST** be domain-explicit in the name when ambiguity is possible (ambiguity is possible when the computed “thing” name refers to a field/group that exists in both **`.spec`** and **`.status`** of the same object).
- If a ComputeReconcileHelper computes values spanning both patch domains, it **MAY** omit `Main` / `Status`.
- ComputeReconcileHelper names SHOULD name the computed “thing”:
  - `computeActualStatus(...)` (ok when actual status is small; otherwise prefer artifact-specific)
  - `computeActualLabels(...)`
  - `computeActualSpecFoo(...)`
  - `computeDesiredStatus(...)`
  - `computeDesiredLabels(...)`
  - `computeDesiredSpecFoo(...)`
  - `computeDesiredChildObjects(...)`
- ComputeReconcileHelper names SHOULD NOT be “vague” (`computeStuff`, `computeAll`, `computeData`) — the intent should be obvious from the name.

---

## Preferred signatures (SHOULD)

Choose the simplest signature that preserves explicit dependencies and purity.

### Simple computation (no flow, no logging) (SHOULD)
```go
func computeDesiredFoo(obj *v1alpha1.Foo) (DesiredFoo, error)
```

Or, if no error is realistically possible:
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo
```

Or, for actual-state computations:
```go
func computeActualFoo(obj *v1alpha1.Foo) (ActualFoo, error)
```

Or, if no error is realistically possible:
```go
func computeActualFoo(obj *v1alpha1.Foo) ActualFoo
```

Or, if a compute helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeDesiredFoo(obj *v1alpha1.Foo) (DesiredFoo, error)
```

Or, if no error is realistically possible:
```go
func (r *Reconciler) computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo
```

Or, for actual-state computations when the helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeActualFoo(obj *v1alpha1.Foo) (ActualFoo, error)
```

Or, if no error is realistically possible:
```go
func (r *Reconciler) computeActualFoo(obj *v1alpha1.Foo) ActualFoo
```

### Complex compute with flow control (SHOULD)
Prefer returning `flow.Outcome` and writing to `out`:
```go
func computeDesiredFoo(ctx context.Context, obj *v1alpha1.Foo, out *DesiredFoo) flow.Outcome
```

Or, if a compute helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeDesiredFoo(ctx context.Context, obj *v1alpha1.Foo, out *DesiredFoo) flow.Outcome
```

Or, for actual-state computations:
```go
func computeActualFoo(ctx context.Context, obj *v1alpha1.Foo, out *ActualFoo) flow.Outcome
```

Or, for actual-state computations when the helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeActualFoo(ctx context.Context, obj *v1alpha1.Foo, out *ActualFoo) flow.Outcome
```

> This keeps the call site clean and avoids `(flow.Outcome, DesiredFoo, error)` tuples.

### Dependent compute (MUST)
If a compute helper depends on previous compute output, the dependency **MUST** be explicit and come **after `obj`**:
```go
func computeDesiredBar(obj *v1alpha1.Foo, desiredFoo DesiredFoo) (DesiredBar, error)
```

Or, for actual-state computations:
```go
func computeActualBar(obj *v1alpha1.Foo, actualFoo ActualFoo) (ActualBar, error)
```

Or, if a compute helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeDesiredBar(obj *v1alpha1.Foo, desiredFoo DesiredFoo) (DesiredBar, error)
```

Or, for actual-state computations when the helper needs data from `Reconciler`:
```go
func (r *Reconciler) computeActualBar(obj *v1alpha1.Foo, actualFoo ActualFoo) (ActualBar, error)
```

---

## Receivers (MUST)

- ComputeReconcileHelpers **SHOULD** be plain functions when they do not need any data from `Reconciler`.
- If a ComputeReconcileHelper needs data from `Reconciler`, it **MUST** be a method on `Reconciler`.

---

## I/O boundaries (MUST)

ComputeReconcileHelpers **MUST NOT** do any of the following:

- controller-runtime client usage (`client.Client`, `r.client`, etc.);
- Kubernetes API calls (`Get/List/Create/Update/Patch/Delete`);
- `DeepCopy` (including `obj.DeepCopy()`, `runtime.Object.DeepCopyObject()`, etc.);
- executing patches (`Patch` / `Status().Patch`) or making any patch ordering / patch type decisions;
- creating/updating Kubernetes objects in the API server in any form.

ComputeReconcileHelpers **MUST NOT** do “hidden I/O” either:

- `time.Now()` / `time.Since(...)` (nondeterministic wall-clock reads);
- random number generation (`rand.*`);
- environment reads (`os.Getenv`, reading files);
- network calls of any kind.

> Rationale: compute helpers should be deterministic and unit-testable; all observable side effects belong to Apply/Patch/Ensure/etc.

---

## Determinism contract (MUST)

A ComputeReconcileHelper **MUST** be deterministic given its explicit inputs and read-only dependencies.

See the common determinism contract in `controller-reconcile-helper.mdc`.

In particular, avoid producing “equivalent but different” outputs across runs (e.g., unstable ordering).
- ComputeReconcileHelpers **MAY** use extracted computation/caching components owned by the reconciler (e.g. “world view” / “planner” / “topology scorer”, unique ID pools, caches), as described in `controller-file-structure.mdc` (“Additional components”), as long as they do not violate the I/O boundaries above.
  - Note: cache population or allocating an ID from a pool is a side effect and an additional source of state; therefore, the helper is deterministic only relative to that state. For the same explicit inputs and the same state of these components, the result **MUST** be the same.
- If a ComputeReconcileHelper returns `flow.Outcome`, its **flow decision** and **error** **MUST** be stable for the same inputs and object state.

> Practical reason: nondeterminism creates patch churn and flaky tests.

---

## Read-only contract (MUST)

`computeDesired*` / `ComputeDesired*` and `computeActual*` / `ComputeActual*` **MUST** treat all inputs as read-only:

- it **MUST NOT** mutate any input values (including `obj` and any computed dependencies passed after `obj`);
- it **MUST NOT** perform in-place modifications through aliases.

Note: reconciler-owned deterministic components (e.g. caches, `idpool`) are allowed mutation targets in `compute*` helpers **only** under the constraints defined above (non-I/O, explicit dependency, deterministic relative to the component state).
If a `compute*` helper mutates such a component, its GoDoc comment **MUST** explicitly state that this helper mutates reconciler-owned deterministic state (e.g. `idpool` allocation) and why this is acceptable (rare-case exception).

See the common read-only contract in `controller-reconcile-helper.mdc` (especially the Go aliasing rule for `map` / `[]T`).

---

## Flow phases and `flow.Outcome` (MUST)

- A ComputeReconcileHelper **MUST NOT** create a `reconcile/flow` phase by default.
- A **large** ComputeReconcileHelper **MAY** create a `reconcile/flow` phase (`flow.BeginPhase` / `flow.EndPhase`) **only when it improves structure or diagnostics**.
  - Otherwise (small/straightforward compute), it **MUST NOT** create a phase.
  - If it creates a phase (or writes logs), it **MUST** accept `ctx context.Context` (see `controller-reconcile-helper.mdc`).
- If a ComputeReconcileHelper returns `flow.Outcome`, it **MUST** use helpers from `internal/reconciliation/flow`:
  - `flow.Continue()`, `flow.Done()`, `flow.Fail(err)`, `flow.RequeueAfter(dur)`.

### `flow.Outcome` change / optimistic-lock reporting (MUST NOT)

Compute helpers **MUST NOT** report object changes or optimistic-lock requirements via `flow.Outcome`:
- **MUST NOT** call `ReportChanged` / `ReportChangedIf`
- **MUST NOT** call `RequireOptimisticLock`

Rationale: `Outcome.DidChange()` / `Outcome.OptimisticLockRequired()` semantically mean
“this helper already mutated the target object and the subsequent save of that mutation must use optimistic-lock semantics”.
Compute helpers do not mutate `obj` by contract.

---

### Returning results when using `flow.Outcome` (MAY)

If a ComputeReconcileHelper returns `flow.Outcome`, it **MAY** write its computed result into an explicit output argument passed by pointer (e.g. `*DesiredState` / `*ActualState`) instead of returning that result as an additional return value.

- It **MUST NOT** write the result into `obj`.

Example pattern (illustrative):
```go
func (r *Reconciler) computeDesiredX(ctx context.Context, obj *v1alpha1.X, out *DesiredX) flow.Outcome {
    if out == nil {
        return flow.Fail(fmt.Errorf("out is nil"))
    }

    // compute into *out (pure)
    *out = DesiredX{ /* ... */ }

    return flow.Continue()
}
```

---

## Patch-domain separation (MUST)

- `computeDesired*` / `ComputeDesired*` and `computeActual*` / `ComputeActual*` **MAY** analyze **both** patch domains (main and status).
- If a `computeDesired*` helper derives **desired** values for **both** domains (main + status), and those desired values will later be used by `IsUpToDate` and/or `Apply`, it **MUST** return **two separate** values (main + status), not a single “mixed” struct.
- If a `computeActual*` helper derives actual (derived) values that are used only as intermediate inputs for other compute helpers, it **MAY** return them in any shape that is convenient for that internal composition (including a single struct).

✅ Separate desired values (GOOD)
```go
func (r *Reconciler) computeDesiredX(obj *v1alpha1.X) (desiredMain DesiredLabels, desiredStatus DesiredXStatus, err error)
```

❌ Mixed (BAD)
```go
func (r *Reconciler) computeDesiredX(obj *v1alpha1.X) (desired MixedDesiredX, err error) // main+status intermingled
```

Notes (SHOULD):
- “Main” typically includes metadata/spec of the root object and/or child objects (desired or actual, depending on the helper).
- “Status” typically includes conditions, observed generation, and other status-only values (desired or actual, depending on the helper).

---

## Composition (MUST)

- A ComputeReconcileHelper **MAY** compute multiple related outputs (desired and/or actual) in one pass.
  - If these outputs are **not distinguishable for external code** (they represent one conceptual “state”), it **SHOULD** return them as **one object** (small struct, anonymous struct, slice/map).
  - If these outputs **are distinguishable for external code** (they are meaningfully different and will be used independently), it **SHOULD** return them as **separate objects**.
- A `computeDesired*` / `ComputeDesired*` helper **MAY** call other `computeDesired*` and `computeActual*` helpers (pure composition).
- A `computeActual*` / `ComputeActual*` helper **MAY** call other `computeActual*` helpers only (pure composition).
- A ComputeReconcileHelper **MAY** depend on outputs of previous compute helpers:
  - the dependency **MUST** be explicit in the signature as additional args **after `obj`**.

---

## Error handling (SHOULD)

- See the common error handling rules in `controller-reconcile-helper.mdc`.
- ComputeReconcileHelpers SHOULD generally return errors as-is.
  - If a ComputeReconcileHelper returns `flow.Outcome`, use `flow.Fail(err)` for errors.

  **Allowed (rare)**: when propagating a **non-local** error (e.g., from parsing/validation libs or injected pure components) and additional context is necessary to **disambiguate multiple different error sources** within the same calling Reconcile method, a ComputeReconcileHelper MAY wrap with small, local context:
  - prefer `fmt.Errorf("<local-action>: %w", err)`
  - keep `<local-action>` specific to the helper responsibility (e.g., `parseDesiredTopology`, `computeDesiredLabels`, `normalizeReplicaSet`)

  **Forbidden (MUST NOT)**:
  - do not add reconcile object identity (e.g. `namespace/name`, UID, object key)
  - do not add generic “outside world” context (that belongs to the Reconcile method)

---

## Common anti-patterns (MUST NOT)

❌ Doing any Kubernetes API I/O (directly or indirectly):
```go
func (r *Reconciler) computeDesiredFoo(ctx context.Context, obj *v1alpha1.Foo) (DesiredFoo, error) {
    var cm corev1.ConfigMap
    if err := r.client.Get(ctx, nn, &cm); err != nil { // forbidden: I/O in compute
        return DesiredFoo{}, err
    }
    return DesiredFoo{}, nil
}
```

❌ Executing a patch / update / delete (or hiding it behind helpers):
```go
func computeActualFoo(ctx context.Context, obj *v1alpha1.Foo) (ActualFoo, error) {
    _ = patchFoo(ctx, obj) // forbidden: patch execution in compute
    return ActualFoo{}, nil
}
```

❌ Calling `DeepCopy` as a shortcut (or to “avoid aliasing”):
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    _ = obj.DeepCopy() // forbidden in compute helpers
    return DesiredFoo{}
}
```

❌ Mutating `obj` (including “harmless” metadata/spec/status writes):
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    obj.Spec.Replicas = 3 // forbidden: compute must not mutate obj
    return DesiredFoo{}
}
```

❌ Mutating `obj` through aliasing of maps/slices:
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    labels := obj.GetLabels()
    labels["my-controller/owned"] = "true" // forbidden: mutates obj via alias
    return DesiredFoo{}
}
```

❌ Returning references that alias `obj` internals (callers may mutate later):
```go
func computeActualFoo(obj *v1alpha1.Foo) ActualFoo {
    return ActualFoo{
        Labels: obj.GetLabels(), // forbidden: exposes obj map alias
    }
}
```

❌ Hidden I/O / nondeterminism (time, random, env, filesystem, extra network):
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    _ = time.Now()     // forbidden
    _ = rand.Int()     // forbidden
    _ = os.Getenv("X") // forbidden
    // net/http calls, reading files, etc. are also forbidden
    return DesiredFoo{}
}
```

❌ Depending on map iteration order (unstable output → patch churn):
```go
func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    out := make([]string, 0, len(obj.Spec.Flags))
    for k := range obj.Spec.Flags { // map iteration order is random
        out = append(out, k)
    }
    // missing sort => nondeterministic output
    return DesiredFoo{Keys: out}
}
```

❌ Mixing desired main + desired status into one “mixed” desired value used by Apply/IsUpToDate:
```go
type MixedDesiredFoo struct {
    Labels map[string]string
    Status v1alpha1.FooStatus
}

func computeDesiredFoo(obj *v1alpha1.Foo) (MixedDesiredFoo, error) { // forbidden shape
    return MixedDesiredFoo{}, nil
}
```

❌ Smuggling implicit dependencies instead of explicit arguments:
```go
var globalDefault DesiredFoo // forbidden: implicit dependency

func computeDesiredFoo(obj *v1alpha1.Foo) DesiredFoo {
    return globalDefault // hidden dependency: not explicit in signature
}
```

❌ Writing results into `obj` instead of returning them / writing into an explicit `out` arg:
```go
func computeActualFoo(obj *v1alpha1.Foo) ActualFoo {
    obj.Status.ObservedGeneration = obj.Generation // forbidden: compute writes into obj
    return ActualFoo{}
}

❌ Using `flow.Outcome` change / optimistic-lock reporting in compute:
```go
func computeDesiredFoo(ctx context.Context, obj *v1alpha1.Foo, out *DesiredFoo) flow.Outcome {
    *out = DesiredFoo{ /* ... */ }
    return flow.Continue().ReportChanged().RequireOptimisticLock() // forbidden in compute
}
```
```
